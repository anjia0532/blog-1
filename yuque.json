[
  {
    "title": "如何用语雀写博客？",
    "description": "前言过去我总是以用什么工具来写文档（文章）而纠结，直到遇见了语雀。yuque-blog 是最近这几个周末用业余时间设计和实现的一个博客系统，核心目标是：“在语雀上（和你的小伙伴一起）编辑文章，在自己的网站上展示文章”。它基于语雀，实现了博客内容页面的自定义输出，支持同构直出、离线访问等特性；技...",
    "created_at": "2018-08-25T06:48:56.000Z",
    "updated_at": "2018-11-22T14:47:06.000Z",
    "published_at": "2018-11-22T14:47:06.000Z",
    "format": "asl",
    "slug": "doib49",
    "last_editor": {
      "id": 103147,
      "type": "User",
      "login": "yinzhi",
      "name": "尹挚",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "followers_count": 9,
      "following_count": 5,
      "created_at": "2018-04-23T00:50:24.000Z",
      "updated_at": "2018-11-20T01:24:53.000Z",
      "_serializer": "v2.user"
    },
    "body": "## <a name=\"zv2lxl\"></a>前言\n\n过去我总是以用什么工具来写文档（文章）而纠结，直到遇见了[语雀](https://www.yuque.com/)。\n\n[yuque-blog](https://github.com/x-cold/yuque-blog) 是最近这几个周末用业余时间设计和实现的一个博客系统，核心目标是：“在语雀上（和你的小伙伴一起）编辑文章，在自己的网站上展示文章”。它基于语雀，实现了博客内容页面的自定义输出，支持同构直出、离线访问等特性；技术架构上，我选用了 beidou (基于 eggjs 的同构框架) 作为后端框架，前端框架采取了常见的 React 全家(半)桶。\n\n[yuque-hexo](https://github.com/x-cold/yuque-hexo) 是用于下载语雀的文章到 hexo 的文章目录下的一款命令行工具。\n\n<!-- more -->\n\n## <a name=\"ghgwlq\"></a>调研阶段\n\n常见的博客平台根据其形态大致分为以下几类：\n\n* 无后台（静态部署）\n    * 静态页面 + 静态内容\n    * 静态页面 + 动态内容管理\n* 有后台\n\n一般来说，在服务器资源允许的条件下，有后台的博客系统（基于 PHP 的 WordPress，使用 Node.js 的 Ghost）是比较普遍的方案，通常情况都会提供一个内容管理的后台管理页面，让写者集中在写作本身，没有太多额外的（技术性）操作；下面可以在几方面稍微对比一下，不同方案下的优劣；\n\n<div class=\"bi-table\">\n  <table>\n    <colgroup>\n      <col width=\"auto\" />\n      <col width=\"auto\" />\n      <col width=\"auto\" />\n      <col width=\"auto\" />\n    </colgroup>\n    <tbody>\n      <tr>\n        <td rowspan=\"1\" colSpan=\"1\">\n          <div data-type=\"p\">​</div>\n        </td>\n        <td rowspan=\"1\" colSpan=\"1\">\n          <div data-type=\"p\">完全静态</div>\n        </td>\n        <td rowspan=\"1\" colSpan=\"1\">\n          <div data-type=\"p\">静态页面+第三方内容管理</div>\n        </td>\n        <td rowspan=\"1\" colSpan=\"1\">\n          <div data-type=\"p\">完全动态</div>\n        </td>\n      </tr>\n      <tr>\n        <td rowspan=\"1\" colSpan=\"1\">\n          <div data-type=\"p\">经典案例</div>\n        </td>\n        <td rowspan=\"1\" colSpan=\"1\">\n          <div data-type=\"p\">GIthub Pages（Hexo / Hugo）</div>\n        </td>\n        <td rowspan=\"1\" colSpan=\"1\">\n          <div data-type=\"p\">Github Pages + Github Issue</div>\n          <div data-type=\"p\">Github Pages + Serverless</div>\n        </td>\n        <td rowspan=\"1\" colSpan=\"1\">\n          <div data-type=\"p\">WordPress / Ghost / Calypso / Typecho</div>\n        </td>\n      </tr>\n      <tr>\n        <td rowspan=\"1\" colSpan=\"1\">\n          <div data-type=\"p\">内容管理</div>\n        </td>\n        <td rowspan=\"1\" colSpan=\"1\">\n          <div data-type=\"p\">+</div>\n        </td>\n        <td rowspan=\"1\" colSpan=\"1\">\n          <div data-type=\"p\">++</div>\n        </td>\n        <td rowspan=\"1\" colSpan=\"1\">\n          <div data-type=\"p\">+++</div>\n        </td>\n      </tr>\n      <tr>\n        <td rowspan=\"1\" colSpan=\"1\">\n          <div data-type=\"p\">团队协作</div>\n        </td>\n        <td rowspan=\"1\" colSpan=\"1\">\n          <div data-type=\"p\">++</div>\n        </td>\n        <td rowspan=\"1\" colSpan=\"1\">\n          <div data-type=\"p\">+++</div>\n        </td>\n        <td rowspan=\"1\" colSpan=\"1\">\n          <div data-type=\"p\">+++</div>\n        </td>\n      </tr>\n      <tr>\n        <td rowspan=\"1\" colSpan=\"1\">\n          <div data-type=\"p\">文章编辑</div>\n        </td>\n        <td rowspan=\"1\" colSpan=\"1\">\n          <div data-type=\"p\">+</div>\n        </td>\n        <td rowspan=\"1\" colSpan=\"1\">\n          <div data-type=\"p\">++</div>\n        </td>\n        <td rowspan=\"1\" colSpan=\"1\">\n          <div data-type=\"p\">+++</div>\n        </td>\n      </tr>\n      <tr>\n        <td rowspan=\"1\" colSpan=\"1\">\n          <div data-type=\"p\">RSS 订阅</div>\n        </td>\n        <td rowspan=\"1\" colSpan=\"1\">\n          <div data-type=\"p\">+++</div>\n        </td>\n        <td rowspan=\"1\" colSpan=\"1\">\n          <div data-type=\"p\">+++</div>\n        </td>\n        <td rowspan=\"1\" colSpan=\"1\">\n          <div data-type=\"p\">+++</div>\n        </td>\n      </tr>\n      <tr>\n        <td rowspan=\"1\" colSpan=\"1\">\n          <div data-type=\"p\">可扩展性</div>\n        </td>\n        <td rowspan=\"1\" colSpan=\"1\">\n          <div data-type=\"p\">+</div>\n        </td>\n        <td rowspan=\"1\" colSpan=\"1\">\n          <div data-type=\"p\">++</div>\n        </td>\n        <td rowspan=\"1\" colSpan=\"1\">\n          <div data-type=\"p\">+++</div>\n        </td>\n      </tr>\n      <tr>\n        <td rowspan=\"1\" colSpan=\"1\">\n          <div data-type=\"p\">社会化生态</div>\n        </td>\n        <td rowspan=\"1\" colSpan=\"1\">\n          <div data-type=\"p\">+++</div>\n        </td>\n        <td rowspan=\"1\" colSpan=\"1\">\n          <div data-type=\"p\">+++</div>\n        </td>\n        <td rowspan=\"1\" colSpan=\"1\">\n          <div data-type=\"p\">+++</div>\n        </td>\n      </tr>\n      <tr>\n        <td rowspan=\"1\" colSpan=\"1\">\n          <div data-type=\"p\">首屏加载</div>\n        </td>\n        <td rowspan=\"1\" colSpan=\"1\">\n          <div data-type=\"p\">+++</div>\n        </td>\n        <td rowspan=\"1\" colSpan=\"1\">\n          <div data-type=\"p\">+</div>\n        </td>\n        <td rowspan=\"1\" colSpan=\"1\">\n          <div data-type=\"p\">++</div>\n        </td>\n      </tr>\n      <tr>\n        <td rowspan=\"1\" colSpan=\"1\">\n          <div data-type=\"p\">缓存加载</div>\n        </td>\n        <td rowspan=\"1\" colSpan=\"1\">\n          <div data-type=\"p\">++</div>\n        </td>\n        <td rowspan=\"1\" colSpan=\"1\">\n          <div data-type=\"p\">+++</div>\n        </td>\n        <td rowspan=\"1\" colSpan=\"1\">\n          <div data-type=\"p\">++</div>\n        </td>\n      </tr>\n      <tr>\n        <td rowspan=\"1\" colSpan=\"1\">\n          <div data-type=\"p\">SEO</div>\n        </td>\n        <td rowspan=\"1\" colSpan=\"1\">\n          <div data-type=\"p\">+++</div>\n        </td>\n        <td rowspan=\"1\" colSpan=\"1\">\n          <div data-type=\"p\">+</div>\n        </td>\n        <td rowspan=\"1\" colSpan=\"1\">\n          <div data-type=\"p\">+++</div>\n        </td>\n      </tr>\n      <tr>\n        <td rowspan=\"1\" colSpan=\"1\">\n          <div data-type=\"p\">性能</div>\n        </td>\n        <td rowspan=\"1\" colSpan=\"1\">\n          <div data-type=\"p\">+++</div>\n        </td>\n        <td rowspan=\"1\" colSpan=\"1\">\n          <div data-type=\"p\">++</div>\n        </td>\n        <td rowspan=\"1\" colSpan=\"1\">\n          <div data-type=\"p\">+</div>\n        </td>\n      </tr>\n      <tr>\n        <td rowspan=\"1\" colSpan=\"1\">\n          <div data-type=\"p\">环境简易程度</div>\n        </td>\n        <td rowspan=\"1\" colSpan=\"1\">\n          <div data-type=\"p\">+++（静态文件服务器）</div>\n        </td>\n        <td rowspan=\"1\" colSpan=\"1\">\n          <div data-type=\"p\">++（静态文件服务器+第三方内容管理系统）</div>\n        </td>\n        <td rowspan=\"1\" colSpan=\"1\">\n          <div data-type=\"p\">+（独立部署的 HTTP 服务）</div>\n        </td>\n      </tr>\n    </tbody>\n  </table>\n</div>\n\n## <a name=\"c8rbcf\"></a>灵光乍现\n\n语雀是一款拥有非常优秀的编辑 / 阅读体验，支持团队协作的知识创作平台；TXD 团队博客包含前端、视觉、交互同学积累的精华文章，由于成员背景原因（设计写代码？？?），方案 1 和 方案 2 显然不是最佳的选择（设计师的学习成本和内容维护难易度），加上团队里面日常工作中使用语雀来编辑文档和知识仓库梳理，为了降低写作者的学习成本，以及提供良好的编辑体验，决定基于语雀去开发一套完全动态的博客系统。\n\n其中实现的主要的特性如下：\n\n* 优秀的文档编辑和管理体验（Powered by 语雀）\n* 极速输出博客页面\n* 可定制的博客主题\n* 支持服务端渲染\n* 支持 PWA 及离线访问\n* 便捷的运维体验，提供一键部署的 Docker 镜像\n\n## <a name=\"ugu4uf\"></a>脑洞大开\n\n对于一些有专业背景的同学而言，Github Pages 是最好的博客载体，其要求我们能够提供一个可以输出静态页面的版本；考虑到大多数同学原有的一些基础建设，决定不再重复制作轮子，于是便基于 hexo 开始设计和思考，经过了一系列的预研工作（看源码、找参考……），最终一把梭开发了一个无侵入的命令行小工具 [yuque-hexo](https://github.com/x-cold/yuque-hexo)，只负责同步语雀的文章，下载到本地后生成对应的 hexo 的文章（markdown 文件），对原有的逻辑没有做任何的改造，纯粹的进行了功能扩展。\n\n## <a name=\"yecgrz\"></a>总结\n\n言归正传，适合自己的才是最好的，体验一款好的产品，再到利用这个产品来扩展到一些相似的场景下，然后系统性的对该场景下的各种设计进行了调研分析和总结，从而达到提升体验和效率的目的。\n\n\n\n"
  },
  {
    "title": "Javascript 模块化指北",
    "description": "tags: [javascript, 模块化]date: 2018-08-10前言随着 Web 技术的蓬勃发展和依赖的基础设施日益完善，前端领域逐渐从浏览器扩展至服务端（Node.js），桌面端（PC、Android、iOS），乃至于物联网设备（IoT），其中 JavaScript 承载着这些应用程序的核心部分，随着其规模化和复杂度的成倍增长，其软件工程体系也随之建立起来（协同开发、单元测试、需求和缺陷管理等），模块化编程的需求日益迫切。JavaScript...",
    "created_at": "2018-08-09T08:27:39.000Z",
    "updated_at": "2018-09-15T09:39:39.000Z",
    "published_at": "2018-09-15T09:39:39.000Z",
    "format": "asl",
    "slug": "gdquyk",
    "last_editor": {
      "id": 103147,
      "type": "User",
      "login": "yinzhi",
      "name": "尹挚",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "followers_count": 9,
      "following_count": 5,
      "created_at": "2018-04-23T00:50:24.000Z",
      "updated_at": "2018-11-20T01:24:53.000Z",
      "_serializer": "v2.user"
    },
    "tags": [
      "javascript",
      "模块化"
    ],
    "date": "2018-08-10 00:00:00 +0800",
    "body": "\n## <a name=\"k2g2vk\"></a>前言\n\n随着 Web 技术的蓬勃发展和依赖的基础设施日益完善，前端领域逐渐从浏览器扩展至服务端（Node.js），桌面端（PC、Android、iOS），乃至于物联网设备（IoT），其中 JavaScript 承载着这些应用程序的核心部分，随着其规模化和复杂度的成倍增长，其软件工程体系也随之建立起来（协同开发、单元测试、需求和缺陷管理等），模块化编程的需求日益迫切。\n\nJavaScript 对模块化编程的支持尚未形成规范，难以堪此重任；一时间，江湖侠士挺身而出，一路披荆斩棘，从刀耕火种过渡到面向未来的模块化方案；\n\n<!-- more -->\n\n## <a name=\"9qopit\"></a>概念\n\n模块化编程就是通过组合一些__相对独立可复用的模块__来进行功能的实现，其最核心的两部分是__定义模块__和__引入模块__；\n\n* 定义模块时，每个模块内部的执行逻辑是不被外部感知的，只是导出（暴露）出部分方法和数据；\n* 引入模块时，同步 / 异步去加载待引入的代码，执行并获取到其暴露的方法和数据；\n\n## <a name=\"01ifuf\"></a>刀耕火种\n\n尽管 JavaScript 语言层面并未提供模块化的解决方案，但利用其可__面向对象__的语言特性，外加__设计模式__加持，能够实现一些简单的模块化的架构；经典的一个案例是利用单例模式模式去实现模块化，可以对模块进行较好的封装，只暴露部分信息给需要使用模块的地方；\n\n```javascript\n// Define a module\nvar moduleA = (function ($, doc) {\n  var methodA = function() {};\n  var dataA = {};\n  return {\n    methodA: methodA,\n    dataA: dataA\n  };\n})(jQuery, document);\n\n// Use a module\nvar result = moduleA.mehodA();\n```\n\n直观来看，通过立即执行函数（IIFE）来声明依赖以及导出数据，这与当下的模块化方案并无巨大的差异，可本质上却有千差万别，无法满足的一些重要的特性；\n\n* 定义模块时，声明的依赖不是强制自动引入的，即在定义该模块之前，必须手动引入依赖的模块代码；\n* 定义模块时，其代码就已经完成执行过程，无法实现按需加载；\n* 跨文件使用模块时，需要将模块挂载到全局变量（window）上；\n\n## <a name=\"9pfbgf\"></a>AMD & CMD 二分天下\n\n> 题外话：由于年代久远，这两种模块化方案逐渐淡出历史舞台，具体特性不再细聊；\n\n为了解决”刀耕火种”时代存留的需求，AMD 和 CMD 模块化规范问世，解决了在浏览器端的异步模块化编程的需求，__其最核心的原理是通过动态加载 script 和事件监听的方式来异步加载模块；__\n\nAMD 和 CMD 最具代表的两个作品分别对应 require.js 和 sea.js；其主要区别在于依赖声明和依赖加载的时机，其中 require.js 默认在声明时执行， sea.js 推崇懒加载和按需使用；另外值得一提的是，CMD 规范的写法和 CommonJS 极为相近，只需稍作修改，就能在 CommonJS 中使用。参考下面的 Case 更有助于理解；\n\n```javascript\n// AMD\ndefine(['./a','./b'], function (moduleA, moduleB) {\n  // 依赖前置\n  moduleA.mehodA();\n  console.log(moduleB.dataB);\n  // 导出数据\n  return {};\n});\n \n// CMD\ndefine(function (requie, exports, module) {\n  // 依赖就近\n  var moduleA = require('./a');\n  moduleA.mehodA();     \n\n  // 按需加载\n  if (needModuleB) {\n    var moduleB = requie('./b');\n    moduleB.methodB();\n  }\n  // 导出数据\n  exports = {};\n});\n```\n\n## <a name=\"wzgpnz\"></a>CommonJS\n\n2009 年 ty 发布 Node.js 的第一个版本，CommonJS 作为其中最核心的特性之一，适用于服务端下的场景；历年来的考察和时间的洗礼，以及前端工程化对其的充分支持，CommonJS 被广泛运用于 Node.js 和浏览器；\n\n```javascript\n// Core Module\nconst cp = require('child_process');\n// Npm Module\nconst axios = require('axios');\n// Custom Module\nconst foo = require('./foo');\n\nmodule.exports = { axios };\nexports.foo = foo;\n```\n\n### <a name=\"0d7dii\"></a>规范\n\n* module (Object): 模块本身\n* exports (\\*): 模块的导出部分，即暴露出来的内容\n* require (Function): 加载模块的函数，获得目标模块的导出值（基础类型为复制，引用类型为浅拷贝），可以加载内置模块、npm 模块和自定义模块\n\n### <a name=\"1w9atp\"></a>实现\n\n1、模块定义\n\n默认任意 .node .js .json 文件都是符合规范的模块；\n\n2、引入模块\n\n首先从缓存（require.cache）优先读取模块，如果未命中缓存，则进行路径分析，然后按照不同类型的模块处理：\n\n* 内置模块，直接从内存加载；\n* 外部模块，首先进行文件寻址定位，然后进行编译和执行，最终得到对应的导出值；\n\n其中在编译的过程中，Node对获取的JavaScript文件内容进行了头尾包装，结果如下：\n\n```javascript\n(function (exports, require, module, __filename, __dirname) {\n    var circle = require('./circle.js');\n    console.log('The area of a circle of radius 4 is ' + circle.area(4));\n});\n```\n\n### <a name=\"c8gglt\"></a>特性总结\n\n* 同步执行模块声明和引入逻辑，分析一些复杂的依赖引用（如循环依赖）时需注意；\n* 缓存机制，性能更优，同时限制了内存占用；\n* Module 模块可供改造的灵活度高，可以实现一些定制需求（如热更新、任意文件类型模块支持）；\n\n## <a name=\"r463xi\"></a>ES Module（推荐使用）\n\nES Module 是语言层面的模块化方案，由 ES 2015 提出，其规范与 CommonJS 比之 ，导出的值<span data-type=\"color\" style=\"color:rgb(26, 26, 26)\"><span data-type=\"background\" style=\"background-color:rgb(255, 255, 255)\">都可以看成是一个具备多个属性或者方法的对象</span></span>，可以实现互相兼容；但写法上 ES Module 更简洁，与 Python 接近；\n\n```javascript\nimport fs from 'fs';\nimport color from 'color';\nimport service, { getArticles } from '../service'; \n\nexport default service;\nexport const getArticles = getArticles;\n```\n\n主要差异在于：\n\n* ES Module 会对<span data-type=\"color\" style=\"color:rgb(26, 26, 26)\"><span data-type=\"background\" style=\"background-color:rgb(255, 255, 255)\">静态代码分析，即在代码编译时进行模块的加载，在运行时之前就已经确定了依赖关系（可解决循环引用的问题）；</span></span>\n* ES Module 关键字：`import` `export` 以及独有的 `default`  关键字，确定默认的导出值；\n* <span data-type=\"color\" style=\"color:rgb(26, 26, 26)\"><span data-type=\"background\" style=\"background-color:rgb(255, 255, 255)\">ES Module 中导入模块的属性或者方法是强绑定的，包括基础类型；</span></span>\n\n## <a name=\"tfbfmg\"></a>UMD\n\n通过一层自执行函数来兼容各种模块化规范的写法，兼容 AMD / CMD / CommonJS 等模块化规范，贴上代码胜过千言万语，需要特别注意的是 ES Module 由于会对静态代码进行分析，故这种运行时的方案无法使用，此时通过 CommonJS 进行兼容；\n\n```javascript\n(function (global, factory) {\n  if (typeof exports === 'object') {   \n    module.exports = factory();\n  } else if (typeof define === 'function' && define.amd) {\n    define(factory);\n  } else {\n    this.eventUtil = factory();\n  }\n})(this, function (exports) {\n ​ // Define Module\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.default = 42;\n});\n```\n\n## <a name=\"8gdlgf\"></a>构建工具中的实现\n\n为了在浏览器环境中运行模块化的代码，需要借助一些模块化打包的工具进行打包（ 以 webpack 为例），定义了项目入口之后，会先快速地进行依赖的分析，然后将所有依赖的模块转换成浏览器兼容的对应模块化规范的实现；\n\n### <a name=\"7sinnb\"></a>模块化的基础\n\n从上面的介绍中，我们已经对其规范和实现有了一定的了解；在浏览器中，要实现 CommonJS 规范，只需要实现 module / exports / require / global 这几个属性，由于浏览器中是无法访问文件系统的，因此 require 过程中的文件定位需要改造为加载对应的 JS 片段（webpack 采用的方式为通过函数传参实现依赖的引入）。具体实现可以参考：[tiny-browser-require](https://github.com/ruanyf/tiny-browser-require)。\n\nwebpack 打包出来的代码快照如下，注意看注释中的时序；\n\n```javascript\n(function (modules) {\n  // The module cache\n  var installedModules = {};\n  // The require function\n  function __webpack_require__(moduleId) {}\n  return __webpack_require__(0); // ---> 0\n})\n({\n  0: function (module, exports, __webpack_require__) {\n    // Define module A\n    var moduleB = __webpack_require__(1); // ---> 1\n  },\n  1: function (module, exports, __webpack_require__) {\n    // Define module B\n    exports = {}; // ---> 2\n  }\n});\n```\n\n实际上，ES Module 的处理同 CommonJS 相差无几，只是在定义模块和引入模块时会去处理 \\_\\_esModule 标识，从而兼容其在语法上的差异。\n\n### <a name=\"oc2kgy\"></a>异步和扩展\n\n1、浏览器环境下，网络资源受到较大的限制，因此打包出来的文件如果体积巨大，对页面性能的损耗极大，因此需要对构建的目标文件进行拆分，同时模块也需要支持动态加载；\n\nwebpack 提供了两个方法 require.ensure() 和 import() （推荐使用）进行模块的动态加载，至于其中的原理，跟上面提及的 AMD & CMD 所见略同，import() 执行后返回一个 Promise 对象，其中所做的工作无非也是动态新增 script 标签，然后通过 onload / onerror 事件进一步处理。\n\n2、由于 require 函数是完全自定义的，我们可以在模块化中实现更多的特性，比如通过修改 require.resolve 或 Module.\\_extensions 扩展支持的文件类型，使得 css / .jsx / .vue / 图片等文件也能为模块化所使用；\n\n## <a name=\"wyfbct\"></a>附录1：特性一览表\n\n| 模块化规范 | 加载方式 | 加载时机 | 运行环境 | 备注 |\n| --- | --- | --- | --- | --- |\n| AMD | 异步 | 运行时 | 浏览器 |  |\n| CMD | 异步 | 运行时 | 浏览器 |  |\n| CommonJS | 同步/异步 | 运行时 | 浏览器 / Node |  |\n| ES Module | 同步/异步 | 编译阶段 | 浏览器 / Node | 通过 import() 实现异步加载 |\n\n## <a name=\"f67zmx\"></a>附录2：参考\n\n* AMD 模块化规范: [https://github.com/amdjs/amdjs-api/wiki/AMD](https://github.com/amdjs/amdjs-api/wiki/AMD)\n* CMD 模块定义规范：[https://github.com/seajs/seajs/issues/242](https://github.com/seajs/seajs/issues/242)\n* webpack 模块相关文档: [https://webpack.js.org/concepts/modules/](https://webpack.js.org/concepts/modules/)\n* 浏览器加载 CommonJS 模块的原理与实现：[http://www.ruanyifeng.com/blog/2015/05/commonjs-in-browser.html](http://www.ruanyifeng.com/blog/2015/05/commonjs-in-browser.html)\n\n\n"
  },
  {
    "title": "你可能不知道的 Date 类",
    "description": "tags: [javascript, 时间处理]date: 2018-03-20Date 是 JS 中的重要的一个内置对象，其实例主要用于处理时间和日期，其时间基于 1970-1-1 (世界标准时间)起的毫秒数，时间戳长度为 13 位（不同于 Unix 时间戳的长度 10 位）。对于日期和时间，我们有无数个使用场景，因此需要特别注意一些细节和约定。1. 构造函数通过 new Date() 可以进行实例化，得到一个 Date 对象实例，值得注意的是如果直接执行 Date() ，将得到一个时间字符串。new...",
    "created_at": "2018-06-29T14:49:02.000Z",
    "updated_at": "2018-09-15T09:40:22.000Z",
    "published_at": "2018-09-15T09:40:22.000Z",
    "format": "asl",
    "slug": "bo4na0",
    "last_editor": {
      "id": 103147,
      "type": "User",
      "login": "yinzhi",
      "name": "尹挚",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "followers_count": 9,
      "following_count": 5,
      "created_at": "2018-04-23T00:50:24.000Z",
      "updated_at": "2018-11-20T01:24:53.000Z",
      "_serializer": "v2.user"
    },
    "tags": [
      "javascript",
      "时间处理"
    ],
    "date": "2018-03-20 00:00:00 +0800",
    "body": "\nDate 是 JS 中的重要的一个内置对象，其实例主要用于处理时间和日期，其时间基于 1970-1-1 (世界标准时间)起的毫秒数，时间戳长度为 13 位（不同于 Unix 时间戳的长度 10 位）。对于日期和时间，我们有无数个使用场景，因此需要特别注意一些细节和约定。\n\n### <a name=\"bw68yn\"></a>1. 构造函数\n\n通过 new Date() 可以进行实例化，得到一个 Date 对象实例，值得注意的是如果直接执行 `Date()` ，将得到一个时间字符串。\n\n```js\nnew Date();\nnew Date(value);\nnew Date(dateString);\nnew Date(year, month[, day[, hour[, minutes[, seconds[, milliseconds]]]]]);\n```\n\n<!-- more -->\n\n其中对构造函数的参数说明(参考 MDN )：\n\n* 如果没有输入任何参数，则Date的构造器会依据系统设置的当前时间来创建一个Date对象。\n* 如果提供了至少两个参数，其余的参数均会默认设置为1（如果没有提供day参数）或者0。\n* JavaScript的时间是由世界标准时间（UTC）1970年1月1日开始，用毫秒计时，一天由86,400,000毫秒组成。Date对象的范围是-100,000,000天至100,000,000天（等效的毫秒值）。\n* JavaScript的Date对象为跨平台提供了统一的行为。时间属性可以在不同的系统中表示相同的时刻，而如果使用了本地时间对象，则反映当地的时间。\n* JavaScript 的Date对象提供了数个UTC时间的方法，也相应提供了当地时间的方法。UTC，也就是我们所说的格林威治时间，指的是time中的世界时间标准。而当地时间则是指执行JavaScript的客户端电脑所设置的时间。\n* 以一个函数的形式来调用JavaScript的Date对象（i.e., 不使用 new 操作符）会返回一个代表当前日期和时间的字符串。\n\n### <a name=\"iw21ng\"></a>2. 空值处理\n\n```js\n// 以chrome为例\nnew Date();\n// Mon Oct 23 2017 23:38:02 GMT+0800 (CST)\n\nnew Date(false);\n// Thu Jan 01 1970 08:00:00 GMT+0800 (CST)\n\nnew Date(0);\n// Thu Jan 01 1970 08:00:00 GMT+0800 (CST)\n\nnew Date(null);\n// Thu Jan 01 1970 08:00:00 GMT+0800 (CST)\n\nnew Date('');\n// Invalid Date\n\nnew Date(undefined);\n// Invalid Date\n```\n\n### <a name=\"4i55ic\"></a>3. 特别提示\n\n[Firefox]\n\n不支持带 '-' 的完整时间，比如 new Date('2012-07-08 00:00:00') 为无效的值，而 new Date('2012-07-08') 是正确的值。\n\n[month]\n\n* new Date(year, month, ……) 中的month从0开始计算\n\n### <a name=\"tfq1kl\"></a>4. 值的边界\n\n不同执行环境下的边界值有差异， Chrome 下甚至连负值都能支持。在实际生产环境中，不仅需要考虑时间的展示，还需要考虑其存储、计算等，因此在特定的场景下，我们需要尽可能考虑到数据库和浏览器中 Date 的有效范围。\n\n以数据库 `Derby` 存储时间为例，其边界为：\n\n| 说明 | 边界值 |\n| :--- | :--- |\n| 最小的日期 | 0001-01-01 |\n| 最大的日期 | 9999-12-31 |\n| 最小的时间 | 00:00:00 |\n| 最大的时间 | 24:00:00 |\n| 最小的时间戳 | 0001-01-01-00.00.00.000000 |\n| 最大的时间戳 | 9999-12-31-23.59.59.999999 |\n\n\n在 `mysql` 中，其范围定义为 `1000-01-01`to`9999-12-31`；\n在 `js` 中，时间戳的最小值为 `-8640000000000000` 即公元前 271,821 年 4 月 20 日，最大值为 `8640000000000000`，即 275,760 年 9 月 13 日。规范中时间范围为 1970/1/1 前后 `100,000,000` 天。\n\n### <a name=\"316knr\"></a>5. 2038 年虫\n\n听说，2038 年之后时间戳不够用了。\n\n> 在计算机应用上，2038年问题可能会导致某些软件在2038年无法正常工作。所有使用UNIX时间表示时间的程序都将受其影响，因为它们以自1970年1月1日经过的秒数（忽略闰秒）来表示时间。这种时间表示法在类Unix（Unix-like）操作系统上是一个标准，并会影响以其C编程语言开发给其他大部份操作系统使用的软件。在大部份的32位操作系统上，此“time\\_t”数据模式使用一个有正负号的32位元整数(signedint32)存储计算的秒数。依照此“time\\_t”标准，在此格式能被表示的最后时间是2038年1月19日03:14:07，星期二（UTC）。超过此一瞬间，时间将会被掩盖（wrap around）且在内部被表示为一个负数，并造成程序无法工作，因为它们无法将此时间识别为2038年，而可能会依个别实作而跳回1970年或1901年。错误的计算及动作可能因此产生。\n\n实际上参考第 4 部分，Date 的上限绰绰有余，大家可以拿起手头的设备测试一下 2038 年会出现怎样的异状。\n\n### <a name=\"rgszhm\"></a>6. 参考\n\n1、EmacScript 语言规范 - [http://ecma-international.org/ecma-262/5.1/#sec-15.9](http://ecma-international.org/ecma-262/5.1/#sec-15.9)\n2、Mysql 时间范围 - [https://dev.mysql.com/doc/refman/5.5/en/datetime.html](https://dev.mysql.com/doc/refman/5.5/en/datetime.html)\n3、JS 时间戳边界 - [https://stackoverflow.com/questions/11526504/minimum-and-maximum-date](https://stackoverflow.com/questions/11526504/minimum-and-maximum-date)\n\n### <a name=\"kkpnsm\"></a>7. 库\n\n* [moment](https://github.com/moment/moment) - 重量级时间处理库，支持时间解析、格式化、计算等，功能强大，支持浏览器和 Node.js，压缩后体积约为 16.3 KB\n* [date-fns](https://github.com/date-fns/date-fns) - 较 moment 更轻量级的事件处理库，体积更小\n* [dayjs](https://github.com/iamkun/dayjs) - 更轻量级的 moment.js\n\n"
  },
  {
    "title": "一套Vue的单页模板：N3-admin",
    "description": "tags: [javascript, vue, N3-components]date: 2017-12-01趁着周末偷来一点闲，总结近期的工作和学习，想着该花点心思把N3-admin这套基于N3-components的单页应用模板简单的给介绍一下。项目路径: https://github.com/N3-components/N3-admin ps: 本项目不同于vue-admin等模板项目介绍大量的组件，基础组件的用法请参考：https://n3-components.github.io/N...",
    "created_at": "2018-06-29T14:47:31.000Z",
    "updated_at": "2018-09-15T08:07:43.000Z",
    "published_at": "2018-09-15T08:07:43.000Z",
    "format": "asl",
    "slug": "iov5sg",
    "last_editor": {
      "id": 103147,
      "type": "User",
      "login": "yinzhi",
      "name": "尹挚",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "followers_count": 9,
      "following_count": 5,
      "created_at": "2018-04-23T00:50:24.000Z",
      "updated_at": "2018-11-20T01:24:53.000Z",
      "_serializer": "v2.user"
    },
    "tags": [
      "javascript",
      "vue",
      "N3-components"
    ],
    "date": "2017-12-01 00:00:00 +0800",
    "body": "\n趁着周末偷来一点闲，总结近期的工作和学习，想着该花点心思把N3-admin这套基于N3-components的单页应用模板简单的给介绍一下。\n\n> 项目路径: [https://github.com/N3-components/N3-admin](https://github.com/N3-components/N3-admin)\n> ps: 本项目不同于vue-admin等模板项目介绍大量的组件，基础组件的用法请参考：[https://n3-components.github.io/N3-components/](https://n3-components.github.io/N3-components/)\n\n## <a name=\"o929fd\"></a>1、概述\n\n首先N3-admin是一个基于 vue / vuex / vue-router / N3 / axios 的单页应用，适用于单页应用的快速上手，并不仅限于N3-components的使用，而是提供一个__比较完善的项目构建的思路和结构__，提供给初学者学习。同时也是一套可扩展的Vue单页应用开发模板。\n\n<!-- more -->\n\n项目工程基于Vue-cli，因此大部分同学都能快速上手和理解，往下介绍一下特性和结构。\n\n## <a name=\"rfs6co\"></a>2、特性\n\n* [x] 项目工程相关\n    * 开发环境；静态文件服务器、HTTP代理、热更新\n    * 生产构建：代码编译提取压缩合并混淆hash命名base64~\n    * eslint\n    * babel\n    * webpack 2.x\n* [x] vue\n    * 组件分级 [路由级组件、复用型组件、基础组件(N3)]\n    * Vue扩展 [filters、directives等]\n* [x] vue-router\n    * 二级路由\n    * 转场动画\n    * 路由拦截器\n* [x] vuex\n    * 多模块(module)支持\n* [x] axios\n    * 支持多实例\n    * 请求、响应拦截器\n    * Vue 扩展，通过实例的方法可访问\n* [x] layout 布局\n* [x] 全局进度条 Nprogress\n* [x] css 预处理\n    * less\n    * postcss\n    * [] stylus         <=  仅需安装预处理器和loader\n    * [] sass / scss    <=  仅需安装预处理器和loader\n* [x] API 调用支持\n    * 接口配置\n    * [x] mock\n\n## <a name=\"ikq0zs\"></a>3、布局方式\n\n> 二级路由下生效\n\n\n\n![image.png | left | 747x572](https://cdn.yuque.com/yuque/0/2018/png/103147/1530283697133-97fca5d9-8f9c-4b07-9e93-55e49b950117.png \"\")\n\n\n## <a name=\"6qzrsw\"></a>4、文件结构\n\n```\n.\n├── README.md                           <=  项目介绍\n├── build                               <=  工程构建相关 <Vue-cli>\n│   ├── build.js                        <=  构建脚本\n│   ├── check-versions.js               <=  Node Npm版本检查\n│   ├── dev-client.js                   <=  开发客户端：浏览器刷新\n│   ├── dev-server.js                   <=  开发服务器：静态文件服务器、代理、热更新\n│   ├── utils.js                        <=  utils\n│   ├── webpack.base.conf.js            <=  webpack基础配置\n│   ├── webpack.dev.conf.js             <=  webpack开发配置\n│   └── webpack.prod.conf.js            <=  webpack生产配置\n├── config                              <=  工程构建配置：开发服务器端口、代理，静态资源打包位置等\n│   ├── dev.env.js                      <=  开发环境配置\n│   ├── index.js                        <=  入口\n│   ├── prod.env.js                     <=  生产环境配置\n│   └── test.env.js                     <=  测试环境配置\n├── index.html                          <=  单页应用入口\n├── package-lock.json                   <=  Npm Package 版本锁\n├── package.json                        <=  Npm Package 配置\n├── src                                 <=  项目源代码\n│   ├── App.vue                         <=  Vue 根组件\n│   ├── api.js                          <=  api 配置\n│   ├── assets                          <=  静态资源\n│   │   ├── font\n│   │   │   ├── iconfont.eot\n│   │   │   ├── iconfont.svg\n│   │   │   ├── iconfont.ttf\n│   │   │   └── iconfont.woff\n│   │   ├── images\n│   │   │   └── logo.png\n│   │   ├── logo.png\n│   │   └── styles\n│   │       └── base.css\n│   ├── config.js                       <=  项目配置\n│   ├── extend                          <=  Vue 扩展相关\n│   │   ├── filters.js                  <=  全局过滤器\n│   │   ├── directive.js                <=  全局指令\n│   │   └── index.js                    <=  扩展入口\n│   ├── layout                          <=  布局组件\n│   │   ├── container.vue\n│   │   ├── header.vue\n│   │   ├── index.vue\n│   │   ├── levelbar.vue\n│   │   └── navbar.vue\n│   ├── main.js                         <=  Vue 入口\n│   ├── mock                            <=  Mock\n│   ├── router                          <=  路由配置\n│   │   ├── index.js\n│   │   └── routes.js\n│   ├── store                           <=  Vuex\n│   │   ├── actions\n│   │   │   └── user.js\n│   │   ├── index.js\n│   │   ├── modules\n│   │   │   ├── app.js\n│   │   │   └── user.js\n│   │   └── mutation-types.js\n│   ├── style                           <=  样式文件 \n│   │   └── define.less\n│   ├── utils                           <=  utils\n│   │   ├── axios.js                    <=  axios\n│   │   ├── const.js                    <=  常量\n│   │   ├── index.js\n│   │   └── storage.js                  <=  storage\n│   └── widgets                         <=  可复用组件\n│   └── views                           <=  路由级别的组件\n│       ├── Login.vue\n│       ├── form\n│       │   └── index.vue\n│       ├── table\n│       │   └── index.vue\n│       └── test\n│           └── query.vue\n├── static                              <=  服务器静态资源\n│   └── favicon.ico\n└── test                                <=  测试文件夹  \n    └── unit\n        ├── index.js\n        ├── karma.conf.js\n        └── specs\n            └── Hello.spec.js\n```\n\n## <a name=\"mgo0eg\"></a>5、使用说明\n\n* 开发环境\n\n```\nnpm run dev\n```\n\n* 生产环境\n\n```\nnpm run build\n```\n\n## <a name=\"zkqutn\"></a>6、效果图\n\n* 总览\n\n\n\n![image.png | left | 747x297](https://cdn.yuque.com/yuque/0/2018/png/103147/1530283709889-82696a81-067e-4481-ac8a-6ecfc91a3909.png \"\")\n\n\n* 登录\n\n\n\n![image.png | left | 747x374](https://cdn.yuque.com/yuque/0/2018/png/103147/1530283720334-3d42f6eb-8edd-4d3a-9a98-ab8655c1d06f.png \"\")\n\n\n* Table\n\n\n\n![image.png | left | 747x304](https://cdn.yuque.com/yuque/0/2018/png/103147/1530283730540-8cb186d9-ee7f-44fb-a9ae-c8c015731e22.png \"\")\n\n\n* Form\n\n\n\n![image.png | left | 747x164](https://cdn.yuque.com/yuque/0/2018/png/103147/1530283737892-39a531dc-d7a2-4e2d-8e06-3a649841ed24.png \"\")\n\n"
  },
  {
    "title": "深入 node node.js 到 windows 环境变量",
    "description": "tags: [javascript, node.js, windows, 环境变量]date: 2017-09-12导读兴许所有程序员都有命名困难症，在考虑变量、常量、方法、类、文件等命名时，总会千方百计尝试一些语义化的方式去实现。曾经有那么一段时间，一些node初学的同学遇到了同样的问题：Hello World 跑不动！！！0. 谜之 Hello World问题的起源非常简单，当我们在编写一个入门程序时，就会迅速想起那句脍炙人口的语句：console.log(&#x27;Hello World&#x2...",
    "created_at": "2018-06-29T14:45:14.000Z",
    "updated_at": "2018-09-15T08:11:48.000Z",
    "published_at": "2018-09-15T08:11:48.000Z",
    "format": "asl",
    "slug": "ha07x2",
    "last_editor": {
      "id": 103147,
      "type": "User",
      "login": "yinzhi",
      "name": "尹挚",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "followers_count": 9,
      "following_count": 5,
      "created_at": "2018-04-23T00:50:24.000Z",
      "updated_at": "2018-11-20T01:24:53.000Z",
      "_serializer": "v2.user"
    },
    "tags": [
      "javascript",
      "node.js",
      "windows",
      "环境变量"
    ],
    "date": "2017-09-12 00:00:00 +0800",
    "body": "\n## <a name=\"bs4ibp\"></a>导读\n\n兴许所有程序员都有命名困难症，在考虑变量、常量、方法、类、文件等命名时，总会千方百计尝试一些语义化的方式去实现。\n\n曾经有那么一段时间，一些node初学的同学遇到了同样的问题：Hello World 跑不动！！！\n\n## <a name=\"pyovmr\"></a>0. 谜之 Hello World\n\n问题的起源非常简单，当我们在编写一个入门程序时，就会迅速想起那句脍炙人口的语句：\n\n```js\nconsole.log('Hello World');\n```\n\n于是乎，顺手保存为node.js，紧接着尝试以`node node.js`来运行该示例程序。毫无疑问，在cmd环境下，会遇到如下的报错：\n\n<!-- more -->\n\n\n\n![image.png | left | 565x416](https://cdn.yuque.com/yuque/0/2018/png/103147/1530283568108-6e8cae58-4157-416f-a72f-3ab1e987d86d.png \"\")\n\n\n\n（PS：实际上无论是Mac、Linux用户，亦或是WIndows中使用Powershell或其他终端环境的同学都无法与此问题完美邂逅）\n\n## <a name=\"revyzg\"></a>1. 初步分析\n\n此时此刻，心中一阵失落，居然连入门的示例程序都无法运行，不禁一阵瞎想：是否该放弃node.js了？\n\n言归正传，细心的同学会发现，报错的源头来自`Windows Script Host`，下简称`WSH`，我们不难查到它是 Windows 操作系统脚本语言程序（script，即：脚本）的运行环境。\n\n## <a name=\"cpxapg\"></a>2. 执行了什么？\n\n简单分析一下`node node.js`这条命令，我们会很自然地认定为：执行node.exe程序，参数为node.js。\n\n然而实际上，真正执行的程序却变成`WSH`，前面执行的命令`node node.js`并没有任何跟调起`WSH`相关的逻辑，因此为何调起了`WSH`成为了解谜的关键。\n\n顺蔓摸瓜，由于`WSH`正好是执行脚本的服务，而js恰恰又是脚本的一种，不妨假设`node.js`这个脚本文件就是罪魁祸首。然后创建一个`test.js`的副本，尝试执行它：\n\n\n\n![image.png | left | 573x328](https://cdn.yuque.com/yuque/0/2018/png/103147/1530283579297-58c3fa0b-a64b-48c6-b48e-2d2d95788c1b.png \"\")\n\n\n### <a name=\"wgicug\"></a>2.1 执行程序的路径\n\n根据试验的结果不难猜出`node node.js`命令实际执行了`node.js`这个脚本文件，从而调起`WSH`服务，进而出现上图的报错。\n\n顺水推舟可确定`node node.js`等价于`.\\node.js node.js`，即命令执行的文件完整的路径为：`E:\\test\\node.js`。\n\n（PS：各位看官切莫介怀''作为路径分隔符，毕竟在cmd下'/'担任参数分隔符的要职）\n\n### <a name=\"lh6byo\"></a>2.2 补全程序的路径\n\n先讲讲通用的说法，无论是 \\* nix 、OS/2 、DOS 亦或是 windows，其terminal都可以通过一个特殊的环境变量`PATH`进行“补全”（关于环境变量的详细内容本文不作介绍）。\n\n接下来我们通过ping命令先做简要说明：\n\n#### <a name=\"18wgxt\"></a>2.2.1 定位程序的路径\n\n\n\n![image.png | left | 462x216](https://cdn.yuque.com/yuque/0/2018/png/103147/1530283587792-4ced2a94-ce79-49de-8ff3-2fc6864b9c1d.png \"\")\n\n\n很明显，在任何一台正常的机器上，这条命令执行后都能得到期待的结果。此时我们可以看到该cmd进程下的`PATH`环境变量中包含`C:\\WINDOWS\\system32`，通过对`PATH`中的元素(文件夹路径)即可将ping程序的路径补全为：`C:\\WINDOWS\\system32\\ping`。（在 \\* nix 系统下依然通用）\n\n\n\n![image.png | left | 747x73](https://cdn.yuque.com/yuque/0/2018/png/103147/1530283599104-8cb6d3a0-8146-4013-8050-c72dc48774a3.png \"\")\n\n\n#### <a name=\"6803ix\"></a>2.2.2 补全后缀名(仅windows、dos)\n\n由于windows的可执行的概念和 \\* nix 略有不同，因此在windows平台下还需要对程序进行后缀名的补全。\n\n其中在 \\* inx下，只需保证文件的结构符合规范，并且拥有可执行权限，就可以执行；而在windows下，还需要考虑其后缀名及执行方式（实际上是一种打开方式的策略）。\n\n```\nE:\\test>echo %PATHEXT%\n.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC;.PY;.PYW;.CPL\n```\n\n最终我们补全的程序路径为：`C:\\WINDOWS\\system32\\ping.exe`，\n\n#### <a name=\"gsrbge\"></a>2.2.3 特别注意(仅windows、dos)\n\n针对于cmd环境，当前目录也会作为路径补全的一部分，并且优先级最高。在当前目录下，我们创建一个`ping.bat`的脚本，并填充以下内容：\n\n```bash\n@echo off\n:: 输出完整的路径和文件名及后缀\necho %~dpnx0\n```\n\n执行结果如下图，原来的`ping.exe`的动作明显被覆盖了。\n\n\n\n![image.png | left | 569x92](https://cdn.yuque.com/yuque/0/2018/png/103147/1530283614729-6819eb33-989b-4506-8bed-b1adbcf1e8fe.png \"\")\n\n\n#### <a name=\"sl0woo\"></a>2.2.4 小结\n\n我们也额外地发现windows的默认可执行的后缀名包含`.JS`，由此可推断最初的那条`node node.js`命令最终补全的程序路径为：`E:\\test\\node.js`\n\n## <a name=\"gpfwgw\"></a>3 打开方式？\n\n从2.2.4的结论中能显而易见的推导出命令执行的程序为`node.js`脚本文件，那么它为什么是通过`WSH`去执行的呢？\n\n答案其实很明显，有个通俗易懂的概念，叫做打开方式，而windows的打开方式由`assoc`和`ftype`确定。\n\n### <a name=\"s6hrwf\"></a>3.1 后缀名与打开方式\n\n尝试性的跑一跑`assoc`命令，发现其控制着后缀名与打开方式`ftype`的关系。\n\n```bat\nassoc | findstr .js\n```\n\n运行结果：\n\n```bat\n.js=JSFile\n.json=VisualStudio.json.14.0\n.jsonld=VisualStudio.jsonld.14.0\n.jsx=VisualStudio.jsx.14.0\n.jsxbin=JSXBINFile\n.jsxinc=JSXINCFile\n```\n\n不难看出`.js`文件将会通过`JSFile`这个打开方式去执行。\n\n### <a name=\"i9gzih\"></a>3.2 打开方式与执行程序\n\n类似的，我们也可以运行一下ftype命令，其定义了可执行程序以及调用的参数。\n\n```bat\nftype | findstr \"JS\"\n```\n\n运行结果：\n\n```\nJSEFile=C:\\Windows\\System32\\WScript.exe \"%1\" %*\nJSFile=C:\\Windows\\System32\\WScript.exe \"%1\" %*\nJSXFile=\"C:\\Program Files (x86)\\Adobe\\Adobe Utilities - CS6\\ExtendScript Toolkit CS6\\ExtendScript Toolkit.exe\" -run \"%1\"\n```\n\n其中最关键的信息为`JSFile=C:\\Windows\\System32\\WScript.exe \"%1\" %*`，含义是通过`WScript.exe`执行js脚本，并将原来的参数传递过去。\n\n最终`node node.js`等价于`E:\\test\\node.js node.js`。\n\n### <a name=\"e1buxd\"></a>3.3 怎么破？\n\n* 发动想象力吧，别再叫`node.js`了~\n* 是时候切换到 \\* inx 或者升级到powershell了~\n* 如果不介意使用绝对路径的话……\n\n## <a name=\"fgo9hh\"></a>4. 扩展学习\n\n操作系统层面通过`PATH`等环境变量进行资源定位的思路实际上也被广泛应用在各种场景下，下面也举两个常见的栗子说明一下。\n\n### <a name=\"lvw4dm\"></a>4.1 npm 包定位\n\nCommonJS 规范中通过`require`去加载模块时，通过路径补全的策略（详情推荐阅读《深入浅出Node.js》），可以省略模块的路径，后缀名，甚至连/index也能自动补全。\n\n### <a name=\"t4egqi\"></a>4.2 webpack资源定位\n\n嘿，resolve中的extensions、alias等思路是否也如出一辙呢？\n\n## <a name=\"fqyqxe\"></a>5. 总结\n\n全文原创·此文为随走随记，全文思维略带感情请勿拍砖。\n"
  },
  {
    "title": "前端人脸检测指南",
    "description": "tags: [javascript, node.js, 人脸检测, AI]date: 2017-08-10 23:28:001 背景与场景Shape Detection API 的发布已经有一些时日，其主要的提供的能力是给予前端直接可用的特征检测的接口（包括条形码、人脸、文本检测）。本文将简单的对其进行介绍，对前端进行人脸检测进行普适性的讲解。[图片]&lt;!-- more --&gt;a. 基于特征的人脸检测例如opencv中内置了基于Viola-Jones目标检测框架的Harr...",
    "created_at": "2018-06-29T14:44:25.000Z",
    "updated_at": "2018-09-15T09:41:17.000Z",
    "published_at": "2018-09-15T09:41:17.000Z",
    "format": "asl",
    "slug": "axnx0z",
    "last_editor": {
      "id": 103147,
      "type": "User",
      "login": "yinzhi",
      "name": "尹挚",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "followers_count": 9,
      "following_count": 5,
      "created_at": "2018-04-23T00:50:24.000Z",
      "updated_at": "2018-11-20T01:24:53.000Z",
      "_serializer": "v2.user"
    },
    "tags": [
      "javascript",
      "node.js",
      "人脸检测",
      "AI"
    ],
    "date": "2017-08-10 23:28:00 +0800",
    "body": "\n## <a name=\"zsa4rb\"></a>1 背景与场景\n\nShape Detection API 的发布已经有一些时日，其主要的提供的能力是给予前端直接可用的特征检测的接口（包括条形码、人脸、文本检测）。本文将简单的对其进行介绍，对前端进行人脸检测进行普适性的讲解。\n\n\n\n![image | left](https://user-gold-cdn.xitu.io/2018/4/25/162fabc3d517af25?w=1080&h=697&f=jpeg&s=66957 \"\")\n\n\n<!-- more -->\n\na. 基于特征的人脸检测\n\n例如opencv中内置了基于Viola-Jones目标检测框架的Harr分类器（实际上大多数分类器都是基于学习得到的），只需要载入对应的配置文件（haarcascade\\_frontalface\\_alt.xml）就能直接调用detectObject去完成检测过程，同时也支持其他特征的检测（如鼻子、嘴巴等）。\n\nb. 基于学习的人脸检测，其实也是需要通过算子提取的图像中的局部特征，通过对其进行分类、统计、回归等方式得到的具备更精确和快响应的分类器。\n\n## <a name=\"tuw9cy\"></a>2 套路集锦\n\n### <a name=\"l2ygpi\"></a>2.1 后端处理\n\n前端通过网络将资源传输到后端，后端统一处理需要检测的图像或视频流，对后端的架构有一定的挑战，同时网络的延时往往不能给用户带来实时的交互效果。\n\n### <a name=\"v9unci\"></a>2.2 客户端处理\n\n得益于OpenCV在跨语言和跨平台的优势，客户端也能以较低的开发成本的提供人脸检测的能力，并且可以通过JsBridge等方式向web容器提供服务，然而一旦脱离这个容器，孤立的页面将失去这种能力。直到有一天……\n\n### <a name=\"ux1dml\"></a>2.3 开放服务\n\n不知道从啥时候开始，云计算等概念拔地而起，计算的成本日益降低。各大研发团队（如阿里云、Face++）都蠢蠢欲动又不紧不慢的上架了人脸检测服务，甚至还带上了各种特！殊！服！务！，人脸识别、活体识别、证件OCR及人脸对比等等等。\n\n\n\n![image | left](https://user-gold-cdn.xitu.io/2018/4/25/162fabc3d514a6e1?w=1080&h=466&f=jpeg&s=65212 \"\")\n\n\n尽管不仅提供了客户端的SDK以及前后端的API，但是，怎么说也要讲讲我纯前端的方案吧。\n\n## <a name=\"fdf8az\"></a>3 时代带来了什么\n\n好吧，人脸识别在前端依然是在刀耕火种的远古时代，然而，我们的基础建设已经起步，希望后续的一些相关介绍能为各位看官带来一定的启发。\n\n### <a name=\"vlrqlg\"></a>3.1 Shape Detection API\n\n随着客户端硬件的计算能力逐渐提高，浏览器层面得到的权限也越来越多，由于图像处理需要耗费大量的计算资源，实际上浏览器上也能承担图像检测的一些工作，因此就搞出了个Shape Detection API。\n\n以下几个简单的例子介绍了基本的用法，在尝试编辑并运行这些代码之前，请确保在你的Chrome版本以及该新特性已经被激活，另外该API受同源策略所限制：\n\n> chrome://flags/#enable-experimental-web-platform-features\n\n条形码检测：Barcode Detection (For Chrome 56+)\n\n```js\nvar barcodeDetector = new BarcodeDetector();\nbarcodeDetector.detect(image)\n  .then(barcodes => {\n    barcodes.forEach(barcode => console.log(barcodes.rawValue))\n  })\n  .catch(err => console.error(err));\n```\n\n人脸检测：Face Detection (For Chrome 56+)\n\n```js\nvar faceDetector = new FaceDetector();\nfaceDetector.detect(image)\n  .then(faces => faces.forEach(face => console.log(face)))\n  .catch(err => console.error(err));\n```\n\n文本检测：Text Detection (For Chrome 58+)\n\n```js\nvar textDetector = new TextDetector();\ntextDetector.detect(image)\n  .then(boundingBoxes => {\n    for(let box of boundingBoxes) {\n      speechSynthesis.speak(new SpeechSynthesisUtterance(box.rawValue));\n    }\n  })\n  .catch(err => console.error(err));\n```\n\n### <a name=\"zhx1de\"></a>3.2 图像中的人脸检测\n\n图像的人脸检测比较简单，只需要传入一个图片的元素，就能直接调起该API进行人脸识别了。然后接住canvas我们可以将检测的结果展示出来。\n\n核心代码：\n\n```js\nvar image = document.querySelector('#image');\nvar canvas = document.querySelector('#canvas');\nvar ctx = canvas.getContext(\"2d\");\nvar scale = 1;\n\nimage.onload = function () {\n  ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);\n  scale = canvas.width / image.width;\n};\n\nfunction detect() {  \n  if (window.FaceDetector == undefined) {\n    console.error('Face Detection not supported');\n    return;\n  } \n  var faceDetector = new FaceDetector();\n  console.time('detect');\n  return faceDetector.detect(image)\n    .then(faces => {\n      console.log(faces)      // Draw the faces on the <canvas>.\n      var ctx = canvas.getContext(\"2d\");\n      ctx.lineWidth = 2;\n      ctx.strokeStyle = \"red\";\n      for (var i = 0; i < faces.length; i++) {\n        var item = faces[i].boundingBox;\n        ctx.rect(Math.floor(item.x * scale), Math.floor(item.y * scale), Math.floor(item.width * scale), Math.floor(item.height * scale));\n        ctx.stroke();\n      }\n      console.timeEnd('detect');\n    })\n    .catch((e) => console.error(\"Boo, Face Detection failed: \" + e));\n}\n```\n\n处理效果：\n\n\n\n![image | left](https://user-gold-cdn.xitu.io/2018/4/25/162fabc3d529f4c9?w=746&h=498&f=jpeg&s=75993 \"\")\n\n\n### <a name=\"4or8vk\"></a>3.3 视频中的人脸检测\n\n视频中的人脸检测跟图像相差不大，通过\n\ngetUserMedia 可以打开摄像头获取视频/麦克风的信息，通过将视频帧进行检测和展示，即可实现视频中的人脸检测。\n\n核心代码如下：\n\n```js\nnavigator.mediaDevices.getUserMedia({\n  video: true,    // audio: true\n})\n  .then(function (mediaStream) {\n    video.src = window.URL.createObjectURL(mediaStream);\n    video.onloadedmetadata = function (e) {\n      // Do something with the video here.\n    };\n  })\n  .catch(function (error) {\n    console.log(error.name);\n  });\n\nsetInterval(function () {\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  ctx.drawImage(video, 0, 0);\n  image.src = canvas.toDataURL('image/png');\n  image.onload = function() {\n    detect();\n  }\n}, 60);\n```\n\n处理效果：\n\n\n\n![image | left](https://user-gold-cdn.xitu.io/2018/4/25/162fabc3d546b78e?w=320&h=235&f=gif&s=306472 \"\")\n\n\n### <a name=\"gqarak\"></a>3.4 时光倒流到没有API的日子\n\n实际上，在很久很久以前，也有不少解决方案存在。由于硬件条件以及没有硬件加速等限制的情况，一直没有被广泛地投入生产。\n\na. tracking.js\n\ntracking.js 是一款js封装的图像处理的库，为浏览器带来丰富的计算视觉相关的算法和技术，通过它可以实现颜色追踪、人脸检测等功能，具体特性如下：\n\n\n\n![image | left](https://user-gold-cdn.xitu.io/2018/4/25/162fabc3d502c2e6?w=1080&h=866&f=jpeg&s=60671 \"\")\n\n\nb. jquery.facedetection\n\njquery.facedetection 是一款jquery / zepto 人脸检测插件，基于跨终端能力超强的ccv中的图像分类器和检测器。\n\n### <a name=\"q8arod\"></a>3.5 Node.js & OpenCV\n\nnode-opencv 模块已经发布了有些年头，尽管目前还不能完美兼容v3.x，提供的API也比较有限，但能完美兼容opencv v2.4.x。N-API的到来可能会带来更多的惊喜。\n\n设想一下在一个Electron或者Node-Webkit容器中，我们是否可以通过本地开启websocket服务来实现实时的人脸检测呢？实现的思路代码如下：\n\n后端处理逻辑\n\n```js\nimport cv from 'opencv';\n\nconst detectConfigFile = './node_modules/opencv/data/haarcascade_frontalface_alt2.xml';\n// camera properties\nconst camWidth = 320;\nconst camHeight = 240;\nconst camFps = 10;\nconst camInterval = 1000 / camFps;\n// face detection properties\nconst rectColor = [0, 255, 0];\nconst rectThickness = 2;\n// initialize cameraconst camera = new cv.VideoCapture(0);\n\ncamera.setWidth(camWidth);\ncamera.setHeight(camHeight);\nconst frameHandler = (err, im) => {\n  return new Promise((resolve, reject) => {\n    if (err) {\n      return reject(err);\n    }\n    im.detectObject(detectConfigFile, {}, (error, faces) => {\n      if (error) {\n        return reject(error);\n      }\n      let face;\n      for (let i = 0; i < faces.length; i++) {\n        face = faces[i];\n        im.rectangle([face.x, face.y], [face.width, face.height], rectColor, rectThickness);\n      }\n      return resolve(im);\n    });\n  });\n};\n\nmodule.exports = function (socket) {\n  const frameSocketHanlder = (err, im) => {\n    return frameHandler(err, im)\n      .then((img) => {\n        socket.emit('frame', {\n          buffer: img.toBuffer(),\n        });\n      });\n  };\n  const handler = () => {\n    camera.read(frameSocketHanlder);\n  };\n  setInterval(handler, camInterval);\n};\n```\n\n前端调用接口\n\n```js\nsocket.on('frame', function (data) {\n\n  var unit8Arr = new Uint8Array(data.buffer);\n  var str = String.fromCharCode.apply(null, unit8Arr);\n  var base64String = btoa(str);\n\n  img.onload = function () {\n    ctx.drawImage(this, 0, 0, canvas.width, canvas.height);\n  }\n  img.src = 'data:image/png;base64,' + base64String;\n});\n```\n\n### <a name=\"gg37oo\"></a>4.1 未来的发展\n\n这些前沿的技术将会在前端得到更为广泛的应用和支持是毋庸置疑的，未来的图像在前端也会随着传统图像处理->学习+图像处理的方式前进，这一切的功劳离不开基础设施(硬件、浏览器、工具、库等)的逐渐增强和完善，其中包括但不仅限于：\n\n* getUserMedia/Canvas => 图像 / 视频的操作\n* Shape Detection API => 图像检测\n* Web Workers => 并行计算能力\n* ConvNetJS => 深度学习框架\n* Tensorflow (原 DeeplearnJS) => 正大力支持 JS\n\n### <a name=\"3arvrk\"></a>4.2 实际上并没有那么乐观\n\n4.2.1 准确率\n\n对于正脸(多个)的识别率还是比较高的，但是在侧脸已经有障碍物的情况下，检测的效果并不理想。\n\n4.2.2 处理速度\n\n对于图像中人脸检测的例子2.2，耗费时间300ms+（实际上无法满足大分辨率视频实时处理），是调用Opencv的检测速度100ms的三倍之多。\n\n4.2.3 特性\n\n还有很多需要完善的地方：如不支持眼镜状态、性别、年龄估计、表情识别、人种、笑容、模糊检测等主流服务提供商提供的服务。\n\n### <a name=\"xk4qxe\"></a>4.3 想说又说不完的\n\na. 本文中所有样例的源代码，欢迎 Fork / Star：\n\n> [https://github.com/x-cold/face-detection-browser](https://github.com/x-cold/face-detection-browser)\n\n> [https://github.com/x-cold/face-detection-nodejs](https://github.com/x-cold/face-detection-nodejs)\n\nb. 关于人脸检测在不同场景的适应性，以及检测消耗的时间暂时没有数据支撑，后面考虑引入PASCAL VOC、AT&T提供的样本进行小规模的测试。\n\n## <a name=\"46l0fn\"></a>5 参考\n\n1. 人脸识别技术大总结(1)：Face Detection & Alignment: [http://blog.jobbole.com/85783/](http://blog.jobbole.com/85783/)\n2. 阿里巴巴直播防控中的实人认证技术: [https://xianzhi.aliyun.com/forum/mobile/read/635.html](https://xianzhi.aliyun.com/forum/mobile/read/635.html)\n3. 前端在人工智能时代能做些什么？：[https://yq.aliyun.com/articles/153198](https://yq.aliyun.com/articles/153198)\n4. ConvNetJS Deep Learning in your browser：[http://cs.stanford.edu/people/karpathy/convnetjs/](http://cs.stanford.edu/people/karpathy/convnetjs/)\n5. Face detection using Shape Detection API：[https://paul.kinlan.me/face-detection/](https://paul.kinlan.me/face-detection/)\n\n\n\n![image | left](https://user-gold-cdn.xitu.io/2018/4/25/162fabc3d5529c80?w=1080&h=1044&f=jpeg&s=133429 \"\")\n\n"
  },
  {
    "title": "powershell测试服务器请求时间",
    "description": "tags: [powershell]date: 2015-02-121、使用基本的cmdletInvoke-WebRequest进行HTTP请求测试# 关于Invoke-WebRequest基本用法 PS &gt; Invoke-WebRequest -Uri &quot;http://www.baidu.com&quot; &lt;!-- more --&gt;Measure-Command对上面的命令进行&quot;计时&quot;PS &gt; Measure-Command -Expression...",
    "created_at": "2018-06-29T14:43:48.000Z",
    "updated_at": "2018-09-15T09:41:57.000Z",
    "published_at": "2018-09-15T09:41:57.000Z",
    "format": "asl",
    "slug": "yxbpzt",
    "last_editor": {
      "id": 103147,
      "type": "User",
      "login": "yinzhi",
      "name": "尹挚",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "followers_count": 9,
      "following_count": 5,
      "created_at": "2018-04-23T00:50:24.000Z",
      "updated_at": "2018-11-20T01:24:53.000Z",
      "_serializer": "v2.user"
    },
    "tags": [
      "powershell"
    ],
    "date": "2015-02-12 00:00:00 +0800",
    "body": "\n### <a name=\"roedeh\"></a>1、使用基本的cmdlet\n\n* Invoke-WebRequest进行HTTP请求测试\n\n```powershell\n# 关于Invoke-WebRequest基本用法\nPS > Invoke-WebRequest -Uri \"http://www.baidu.com\"\n```\n\n<!-- more -->\n\n* Measure-Command对上面的命令进行\"计时\"\n\n```powershell\nPS > Measure-Command -Expression {Invoke-WebRequest -Uri \"http://www.baidu.com\"}\n```\n\n### <a name=\"o0gfrv\"></a>2、源代码：\n\n```powershell\n$url = \"http://www.baidu.com\"\n# 追踪执行命令耗时\n$timeTaken = Measure-Command -Expression {\n  # 保留请求信息，可用于网络爬虫的实现\n  $site = Invoke-WebRequest -Uri $url\n}\n\n# 获取毫秒数\n$milliseconds = $timeTaken.TotalMilliseconds\n$milliseconds = [Math]::Round($milliseconds, 1)\n\nWrite-Host \"It took $milliseconds ms!\"\n```\n\n### <a name=\"nokahz\"></a>3、小结\n\nPowerShell获取网页信息个人建议的三种解决方案：\n\n* WebClient\n* Invoke-WebRequest\n* COM组件\"InternetExplorer.Application\"\n\n"
  },
  {
    "title": "powershell学习之道-文件夹共享及磁盘映射",
    "description": "tags: [powershell]date: 2015-01-19在Linux环境下，我们很轻易就能得心应手地通过命令操作一切事物，在Windows下，Powershell也算是后起之秀，提供大量的cmdlet以及c#的横向拓展。下面将由小编带领大家通过Powershell实现文件夹共享，当然文中也不会冷落cmd这枚老将。文件夹共享概述共享文件夹的应用非常广泛，客户端对服务器端进行文件管理，局域网文件直传等等，在linux下，可以简单的安装smaba协议，简单的配置之后即可使用。在windows...",
    "created_at": "2018-06-29T14:42:26.000Z",
    "updated_at": "2018-09-15T08:16:02.000Z",
    "published_at": "2018-09-15T08:16:02.000Z",
    "format": "asl",
    "slug": "qeqnq1",
    "last_editor": {
      "id": 103147,
      "type": "User",
      "login": "yinzhi",
      "name": "尹挚",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "followers_count": 9,
      "following_count": 5,
      "created_at": "2018-04-23T00:50:24.000Z",
      "updated_at": "2018-11-20T01:24:53.000Z",
      "_serializer": "v2.user"
    },
    "tags": [
      "powershell"
    ],
    "date": "2015-01-19 00:00:00 +0800",
    "body": "\n在Linux环境下，我们很轻易就能得心应手地通过命令操作一切事物，在Windows下，Powershell也算是后起之秀，提供大量的cmdlet以及c#的横向拓展。下面将由小编带领大家通过Powershell实现文件夹共享，当然文中也不会冷落cmd这枚老将。\n\n### <a name=\"7a29ll\"></a>文件夹共享概述\n\n共享文件夹的应用非常广泛，客户端对服务器端进行文件管理，局域网文件直传等等，在linux下，可以简单的安装smaba协议，简单的配置之后即可使用。在windows下，可以通过图形化的操作开启这项功能，当然带着一点极客风格，我们通过powershell（少量出现cmd）来对其进行管理。\n\n<!-- more -->\n\n### <a name=\"qbcvan\"></a>操作步骤\n\n#### <a name=\"8q9yga\"></a>查看共享列表\n\n在powershell内，我们可以通过执行以下cmdlet获取共享信息：\n\n```powershell\nλ Get-WmiObject -Class Win32_Share\n\nName                                      Path                                      Description\n----                                      ----                                      -----------\nADMIN$                                    C:\\Windows                                远程管理\nC$                                        C:\\                                       默认共享\nD$                                        D:\\                                       默认共享\nE$                                        E:\\                                       默认共享\nIPC$                                                                                远程 IPC\nUsers                                     C:\\Users\n```\n\n同理，在cmd下，也可以\n\n```powershell\nλ net share\n\n共享名       资源                            注解\n\n-------------------------------------------------------------------------------\nC$           C:\\                             默认共享\nD$           D:\\                             默认共享\nE$           E:\\                             默认共享\nIPC$                                         远程 IPC\nADMIN$       C:\\Windows                      远程管理\nUsers        C:\\Users\n命令成功完成。\n```\n\n#### <a name=\"gh75ll\"></a>创建一个共享文件夹\n\n__疯狂的Powershell__\n\n```powershell\n# 共享名\n$ShareName = 'TestShare'\n# 共享路径\n$Path = 'D:\\SHARE'\n\nIf (!(Get-WmiObject -Class Win32_Share -Filter \"name='$ShareName'\"))\n{\n\t$Shares = [WMICLASS]\"WIN32_Share\"\n\t$Shares.Create($Path,$ShareName,0).ReturnValue\n}\nelse\n{\n\tWrite-Warning \"$ShareName has been sharing!!\"\n}\n```\n\n如果如果您有远程机器的管理员权限的话，也利用WMI在远程的机器上创建新的共享文件夹，下面是在远程主机上创建共享文件夹的代码：\n\n```powershell\n# 共享名\n$ShareName = 'TestShare'\n# 共享路径\n$Path = 'D:\\SHARE'\n# 远程主机名\n$Server = 'Server'\n\nIf (!(Get-WmiObject -Class Win32_Share -Filter \"name='$ShareName'\"))\n{\n\t$Shares = [WMICLASS]\"\\\\$Server\\root\\cimv2:WIN32_Share\"\n\t$Shares.Create($Path,$ShareName,0).ReturnValue\n}\nelse\n{\n\tWrite-Warning \"$ShareName has been sharing!!\"\n}\n```\n\n__低调的cmd__\n\n```bash\n::建议先查看当前的共享文件夹再进行创建操作\nnet share TestShare=D:\\SHARE /users:25 /remark:\"test share of the a folder\"\n```\n\n我们很轻易地就能将一个文件夹的共享状态开启，我们可以通过UNC路径对其进行访问。创建完文件共享之后，我们来看看怎么使用吧。\n\n#### <a name=\"i2dbgm\"></a>驱动器映射和共享访问\n\n接下来，我们摒弃图形化界面的操作（如果你非喜欢那么做的话，可以通过网上邻居【“网络”】进行查看，或者在计算机图标下右键选择映射网络驱动器），我们来通过命令去启用吧。\n\n__强悍的Powershell__\n\n临时创建一个网络驱动器映射：\n\n```powershell\n(New-Object -ComObject WScript.Network).MapNetworkDrive(\"Z:\", \"\\\\TEST-PC\\USERS\")\n```\n\n创建一个持久化的网络驱动器映射：\n\n```powershell\n# New-PSDrive 加上 -Persist 参数使得驱动器在 PowerShell 之外可见。\n# 要真正地创建一个永久的网络驱动器，请确保加上 -Scope Global。/\n# 如果 New-PSDrive 在全局作用域范围之外运行（例如，在一个脚本中运行），该驱动器只会在脚本运行时出现在文件管理器中。\nNew-PSDrive -Name Z -PSProvider FileSystem -Root \\\\TEST-PC\\USERS -Persist -Scope Global\n```\n\n__小巧的cmd__\n\n```bash\n::下面这条命令虽然可以在cmd使用此磁盘映射，但是不可利用资源管理器加载。\nnet use Z: \\\\TEST-PC\\USERS\n\n::这里是将systemroot文件夹映射为z:驱动器，可利用\"explorer.exe\"加载，可惜不能使用网络路径。\nsubst Z: $env:systemroot\n```\n\n完成如上的工作之后，不出意外，你的资源管理器会出现你想要访问的网络路径的图标。\n\n#### <a name=\"ls7bwy\"></a>删除共享\n\n如果不需要再使用此共享文件夹了，可以卸载掉网络驱动器，并在共享的主机上删除该共享。\n\n__Powershell__\n\n```powershell\n$Shares = Get-WMIObject Win32_Share | Where {$_.Name -eq \"\"}\n\nForeach ($Share in $Shares) {\n   $Share.Delete()\n}\n```\n\n__cmd__\n\n```bash\nnet share TestShare /delete\n```\n\n### <a name=\"z5amwe\"></a>小结\n\n1. 建立共享文件夹需要事先在启用网络共享和发现。\n2. 需要提前做好文件夹权限控制以及共享的权限控制。\n3. 通过配置cmdkey可以免去身份认证 `cmdkey /add:targetname /user:username /pass:password`\n\nPowershell管理共享的相关链接：[https://msdn.microsoft.com/en-us/library/aa394435(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/aa394435(v=vs.85).aspx)\n"
  },
  {
    "title": "WebClient获取网络上的资源",
    "description": "tags: [powershell]date: 2015-02-15WebClient提供向了 URI 标识的资源发送数据和从 URI 标识的资源接收数据的公共方法.下载网页内容1.创建WebClient对象：$web = New-Object System.Net.WebClient 2.设置文本的编码：$web.Encoding = [System.Text.Encoding]::UTF8 3.下载网页代码$str = $web.DownloadString(&quot;http...",
    "created_at": "2018-06-29T14:42:02.000Z",
    "updated_at": "2018-09-15T08:15:40.000Z",
    "published_at": "2018-09-15T08:15:40.000Z",
    "format": "asl",
    "slug": "ynbfpq",
    "last_editor": {
      "id": 103147,
      "type": "User",
      "login": "yinzhi",
      "name": "尹挚",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "followers_count": 9,
      "following_count": 5,
      "created_at": "2018-04-23T00:50:24.000Z",
      "updated_at": "2018-11-20T01:24:53.000Z",
      "_serializer": "v2.user"
    },
    "tags": [
      "powershell"
    ],
    "date": "2015-02-15 00:00:00 +0800",
    "body": "\nWebClient提供向了 URI 标识的资源发送数据和从 URI 标识的资源接收数据的公共方法.\n\n### <a name=\"kczgdx\"></a>下载网页内容\n\n1.创建WebClient对象：\n\n```powershell\n$web = New-Object System.Net.WebClient\n```\n\n2.设置文本的编码：\n\n```powershell\n$web.Encoding = [System.Text.Encoding]::UTF8\n```\n\n3.下载网页代码\n\n```powershell\n$str = $web.DownloadString(\"http://localhost\")\n$str\n```\n\n### <a name=\"0a7vym\"></a>获取文件资源\n\n```\n$url = \"http://path.to/file\"\n$file = \"\\\\localpath\\to\\file\"\n$web.DownloadFile($url,$file)\n```\n\nWebClient能够实现一个HTTP客户端，进而拓展的应用场景非常丰富，如 web自动化，网络爬虫，异步下载器等，更多关于WebClient的说明请参考：[https://msdn.microsoft.com/zh-cn/library/system.net.webclient(VS.80).aspx](https://msdn.microsoft.com/zh-cn/library/system.net.webclient(VS.80).aspx)\n\n相似知识点：`HttpClient`\n"
  },
  {
    "title": "powershell学习之道-入门须知的八个技巧",
    "description": "tags: [powershell]date: 2015-01-28powershell脚本入门须知的八个技巧脚本文件后缀名为 &quot;.ps1&quot; 的文本文件，包含了一系列的powershell命令，每条命令显示为独立的一行；执行策略：about_Execution_Policies，通过下面这条命令查询所有支持的执行策略：[System.Enum]::GetNames([Microsoft.PowerShell.ExecutionPolicy...",
    "created_at": "2018-06-29T14:41:13.000Z",
    "updated_at": "2018-09-15T08:15:07.000Z",
    "published_at": "2018-09-15T08:15:07.000Z",
    "format": "asl",
    "slug": "fbfn65",
    "last_editor": {
      "id": 103147,
      "type": "User",
      "login": "yinzhi",
      "name": "尹挚",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "followers_count": 9,
      "following_count": 5,
      "created_at": "2018-04-23T00:50:24.000Z",
      "updated_at": "2018-11-20T01:24:53.000Z",
      "_serializer": "v2.user"
    },
    "tags": [
      "powershell"
    ],
    "date": "2015-01-28 00:00:00 +0800",
    "body": "\n### <a name=\"k8u7pv\"></a>powershell脚本入门须知的八个技巧\n\n* 脚本文件后缀名为 \".ps1\" 的文本文件，包含了一系列的powershell命令，每条命令显示为独立的一行；\n* 执行策略：about\\_Execution\\_Policies，通过下面这条命令查询所有支持的执行策略：\n\n```powershell\n[System.Enum]::GetNames([Microsoft.PowerShell.ExecutionPolicy])\n```\n\n* 运行脚本：使用绝对路径和相对路径均可运行，与shell命令执行如出一辙；\n* 管道（\"|\"）的作用是将前一条命令的输出作为另一个命令的输入；\n* 变量用 \"\\$\" 进行引用，用 \"@\" 将列表内容转为数组，命令引用数组变量 \"\\$name\" 也可以直接使用 \"@name\" ；\n* \"-split\" 和 \"-join\" 拆分和连接字符串，如下面这条命令可以执行1-100求和：\n\n```powershell\nInvoke-Expression (1..100 -join '+')\n```\n\n* 断点：debug神器，关键字：PSBreakpoint，可以和PSBreakpoint一起使用的动词包括New，Get，Enable，Disable和Remove。下面是分别在行和变量中插入断点：\n\n```powershell\nNew-PSBreakpoint -Script C:\\Scripts\\Script.ps1 -Line 10\nNew-PSBreakpoint -Script C:\\scripts\\Script.ps1 -variables a\n```\n\n* Step，调试一个脚本时，有时可能需要逐行运行脚本，这时你可以使用Step-Into cmdlet命令，它会使脚本一行一行地执行，不管有没有设置断点，如果你想从这种步进式运行模式退出来，使用Step-Out cmdlet命令即可，但需要注意的是，使用Step-Out cmdlet命令后，断点仍然有效。顺便说一句，如果你的脚本使用了函数，你可能对Step-Out cmdlet更感兴趣，Step-Out的工作方式和Step-Into一样，不过，如果调用了一个函数，Windows不会逐步执行，整个函数将会一次性执行。\n\n"
  },
  {
    "title": "树莓派NAS搭建",
    "description": "tags: [linux, 树莓派, nas]date: 2015-10-18 19:25:42初探树莓派，便可知道其用途广泛，本篇博文将介绍如何使用树莓派搭建基于Linux和SMB协议的NAS服务器。树莓派简介树莓派（Raspberry pi，简写为RPi，或者RasPi/RPi）是目前比较常见的卡片电脑，为学生计算机编程教育而设计。其系统基于Linux(或者最新发布的Windows 10 IoT)。仅有巴掌大小的PCB板可谓麻雀虽小五脏俱全，可以像普通的PC那样工作。树莓派型号目前分为A\\B型，其中A...",
    "created_at": "2018-06-29T14:40:05.000Z",
    "updated_at": "2018-09-15T08:17:08.000Z",
    "published_at": "2018-09-15T08:17:08.000Z",
    "format": "asl",
    "slug": "cgm3ug",
    "last_editor": {
      "id": 103147,
      "type": "User",
      "login": "yinzhi",
      "name": "尹挚",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "followers_count": 9,
      "following_count": 5,
      "created_at": "2018-04-23T00:50:24.000Z",
      "updated_at": "2018-11-20T01:24:53.000Z",
      "_serializer": "v2.user"
    },
    "tags": [
      "linux",
      "树莓派",
      "nas"
    ],
    "date": "2015-10-18 19:25:42 +0800",
    "body": "\n初探树莓派，便可知道其用途广泛，本篇博文将介绍如何使用树莓派搭建基于Linux和SMB协议的NAS服务器。\n\n### <a name=\"el9zps\"></a>树莓派简介\n\n树莓派（Raspberry pi，简写为RPi，或者RasPi/RPi）是目前比较常见的卡片电脑，为学生计算机编程教育而设计。其系统基于Linux(或者最新发布的Windows 10 IoT)。仅有巴掌大小的PCB板可谓麻雀虽小五脏俱全，可以像普通的PC那样工作。树莓派型号目前分为A\\B型，其中A型的配置较低，不适合生产环境，本人以B+ model为例讲解后面的内容。树莓派目前主要被用于一些简单的WEB服务以及智能设备、由于Python强大的底层库支持，树莓派也常常被用极客们用于改装各种电子元件。\n\n<!-- more -->\n\n*基本配置：5V2A Micro USB接口、512MB内存、HDMI视频输出口、音频叔叔、26针GPIO*\n\n推荐链接：[树莓派入门须知](http://www.shumeipai.net/thread-21180-1-1.html?_dsign=81e52e75)\n\n### <a name=\"ecixgc\"></a>系统安装\n\n略。\n\n### <a name=\"rg8qig\"></a>入门基础\n\n首先，你必须学会使用简单的linux命令以及工具，从上面的系统安装教程我们可以了解到树莓派一般都会带上一个debian系列的linux系统。下面是常用的linux命令和工具：\n\n* ssh：(Secure Shell)顾名思义，在缺少一套完整的键盘鼠标和HDMI显示器的条件下，我们只能通过SSH（当然其他RPC也是被支持的，如telnet，不过树莓派官方提供的系统已自动为我们启动ssh的服务）连接并操作树莓派。\n* 简单的文件操作命令：`mkdir`,`rmdir`,`rm`,`cd`,`ls`,`cp`,`mv`等\n* 终端文本编辑器：`vi`,`vim`等\n* 基本的系统指令：`exit`,`reboot`,`init 0`,`ps`,`ifconfig`等\n* 包管理（debian系统为例）：apt-get\n* 如果需要远程桌面图形化操作，请安装VNC\n\n### <a name=\"4786hc\"></a>NAS大致构架简介\n\n* 简介\n\nNAS（Network Attached Storage：网络附属存储）即是在网络上提供数据储存的装置，因此也称为“网络存储器”。它是一种专用数据存储服务器。它以数据为中心，将存储设备与服务器彻底分离，集中管理数据，从而释放带宽、提高性能、降低总拥有成本、保护投资。本次设计的NAS主要用于公司内文件共享以及定时备份到远端服务器。\n\n* 硬件架构\n    1. 树莓派B+\\*1\n    2. 立式硬盘盒子\\*1\n    3. 1TB HDD 3.5inch\\*1\n* 软件和网络环境\n    1. os：debian\n    2. 基于协议：SMB\n    3. 依赖服务：smaba\n    4. 基本模块：ntfs-3g、rsync、ssh、crontab\n    5. 网络环境：内网静态IP、可访问远端备份服务器\n\n"
  },
  {
    "title": "Terminal前后端任务切换",
    "description": "tags: [linux, shell]date: 2015-01-16我们在使用Linux的终端执行一些调用程序的命令时，经常需要用到进程前后端转换例：$ firefox http://google.com  # 调用火狐浏览器打开页面 $ gedit grub.cfg  # 经典的gedit用法 这时候我们的程序实际是在前台执行的，这时候对程序的操作能在当前的Terminal查看，这意味着当你关闭Terminal时，你所调用的程序也会自动结束，或者说当你想在当前的Terminal...",
    "created_at": "2018-06-29T14:39:33.000Z",
    "updated_at": "2018-09-15T08:16:34.000Z",
    "published_at": "2018-09-15T08:16:34.000Z",
    "format": "asl",
    "slug": "scqgbg",
    "last_editor": {
      "id": 103147,
      "type": "User",
      "login": "yinzhi",
      "name": "尹挚",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "followers_count": 9,
      "following_count": 5,
      "created_at": "2018-04-23T00:50:24.000Z",
      "updated_at": "2018-11-20T01:24:53.000Z",
      "_serializer": "v2.user"
    },
    "tags": [
      "linux",
      "shell"
    ],
    "date": "2015-01-16 00:00:00 +0800",
    "body": "\n我们在使用Linux的终端执行一些调用程序的命令时，经常需要用到进程前后端转换\n\n### <a name=\"k3e3de\"></a>例：\n\n```bash\n$ firefox http://google.com  # 调用火狐浏览器打开页面\n$ gedit grub.cfg  # 经典的gedit用法\n```\n\n这时候我们的程序实际是在前台执行的，这时候对程序的操作能在当前的Terminal查看，这意味着当你关闭Terminal时，你所调用的程序也会自动结束，或者说当你想在当前的Terminal执行其他命令时，企图按下最常用的Ctrl+C结束当前的命令调用，可是此时你所调用的程序依然会自动结束进程。\n\n<!-- more -->\n\n### <a name=\"g2o8fm\"></a>解决方案：\n\n1.在调用命令执行某个程序时，按下Ctrl+Z而不是Ctrl+C，这个时候将进程交还给Terminal以执行其他的命令，但是这时候所执行的程序会处于就绪态(Stopped)，我们无法对其进行操作。\n\n2.执行命令后面加上\"&\"\n\n```bash\n$ gedit grub.cfg &\n```\n\n这时候Terminal依旧会监视程序的一举一动，但是这时候再按下Ctrl+C试试吧。\n\n3.执行jobs命令进行前后端进程的调度\n\n```bash\n$ jobs -l  #列出当前Terminal调用的任务\n[1]-  2382 Stopped                 gedit\n[2]+  2393 Stopped                 firefox\n[3]   2466 Running                 firefox &\n$ fg 1  # 将序号为1的任务，即gedit切换到前台运行\n$ bg 2  # 将firefox切换到后台运行\n$ kill 3  # 类似\"kill pid\"，此处是任务的序号\n```\n\n### <a name=\"tlqvxm\"></a>小结：\n\n* 前台执行的任务即使是通过Ctrl+Z也会将任务调度到就绪状态(Stopped)\n* 在命令后附加\"&\"实际上相当于执行任务调度\"bg n\"\n* 前台程序可以先通过Ctrl+Z转换到就绪态,再通过\"bg n\"命令调度到后台运行\n* 后天程序可以转到前台，方便Terminal监视程序的变化\n\n"
  },
  {
    "title": "VHD安装系统【概念】",
    "description": "tags: [计算机维护]date: 2015-01-22VHD简介VHD，全称 Virtual Hard Disk ，正如其中文翻译，即是虚拟硬盘[powered by微软]。 简而言之，就是用一个硬盘上的文件来模拟和管理一个全新的物理磁盘，是虚拟化技术的一大利器。 分类(win7下只有固定VHD和动态VHD两种)固定VHD：对已分配的大小不会更改。 动态VHD：大小与写入的数据大小相同，并随着数据的写入而相应增加直到达到大小上限。动态VHD上限为2,040 GB。 差异 VHD ：与动态VHD...",
    "created_at": "2018-06-29T14:39:01.000Z",
    "updated_at": "2018-09-15T09:36:48.000Z",
    "published_at": "2018-09-15T09:36:48.000Z",
    "format": "asl",
    "slug": "xp4ubp",
    "last_editor": {
      "id": 103147,
      "type": "User",
      "login": "yinzhi",
      "name": "尹挚",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "followers_count": 9,
      "following_count": 5,
      "created_at": "2018-04-23T00:50:24.000Z",
      "updated_at": "2018-11-20T01:24:53.000Z",
      "_serializer": "v2.user"
    },
    "tags": [
      "计算机维护"
    ],
    "date": "2015-01-22 00:00:00 +0800",
    "body": "\n### <a name=\"ic0loc\"></a>VHD简介\n\n```\nVHD，全称 Virtual Hard Disk ，正如其中文翻译，即是虚拟硬盘[powered by微软]。\n简而言之，就是用一个硬盘上的文件来模拟和管理一个全新的物理磁盘，是虚拟化技术的一大利器。\n```\n\n### <a name=\"8ks4ee\"></a>分类(win7下只有固定VHD和动态VHD两种)\n\n```\n固定VHD：对已分配的大小不会更改。\n动态VHD：大小与写入的数据大小相同，并随着数据的写入而相应增加直到达到大小上限。动态VHD上限为2,040 GB。\n差异 VHD ：与动态VHD 类似，但只包含所关联父VHD修改后的磁盘块。差异VHD的上限为2,040 GB。[1]\n链接硬盘VHD：文件本身指向一个磁盘或者一个分区。\n```\n\n<!-- more -->\n\n### <a name=\"8o3gle\"></a>功能广泛\n\n* 安装无盘操作系统，是公共场合（如网吧）非常适合使用这项技术。特点是维护方便，因为在虚拟硬盘的操作系统进行的操作几乎不会对计算机本身造成影响，而且这意味这客户端机子可以不需要配备硬盘而是直接通过NETBIOS等手段从服务器端进行引导。\n* 安装多个操作系统，从其他计算机直接克隆操作系统。由于是用一个或者多个文件来管理一整个硬盘，因此对硬盘的整体转移和克隆变得非常地简单，甚至可以说移植一个VHD的操作系统只需要拷贝这个磁盘文件（占用空间略大），然后进行引导修复便可。\n* 给虚拟机使用并可以作为一个独立的系统测试空间，例如一些高危的病毒文件行为分析，便可以通过使用此VHD的虚拟机进行测试，然后通过物理机直接读取日志。\n\n### <a name=\"nvzubu\"></a>安装系统\n\n* 可以采用传统的各种方式来安装操作系统，不过在这之前需要提前装载好磁盘。\n* 添加引导文件的时候需要注意系统所在分区（或者引导分区）所在的路径，格式为(hd(n,m)[n为硬盘序号，m为分区序号])，当然你也可以直接用bcd添加已经装载此磁盘的盘符进行引导添加，这将会自动拓展到一个完整的分区路径(hd(n,m))。\n* 硬盘分区表格式需要和计算机自带的硬盘格式一致，如果你的计算机是GPT分区+UEFI，那么你最好选择把虚拟硬盘的格式设置为GPT格式。\n\n### <a name=\"gc9qxq\"></a>管理工具DISKPART\n\n```Bash\n>\\ diskpart\n\n::创建VHD\n>\\ create vdisk file=D:\\win7.vhd maximum=15000 type=fixed\n\n::选择VHD\n>\\ select vdisk file=D:\\win7.vhd\n\n::装载VHD\n>\\ attach vdisk\n\n::建立分区\n>\\ create partition primary\n\n::给分区分配盘符\n>\\ assign letter=v\n\n::格式化分区\n>\\ format quick lable=vhddWin\n\n::无损扩容\n>\\ diskpart\n>\\ sel vdisk file=D:\\win7.vhd\n>\\ expand vdisk maximum=20000\n>\\ list vol\n>\\ sel vol 4\n>\\ extend\n\n::退出diskpart\n>\\ exit\n```\n\n"
  },
  {
    "title": "imagex.exe花式装系统",
    "description": "tags: [计算机维护]date: 2015-01-20imagex.exe简介imagex.exe是一款用来捕获、修改和应用基于文件的磁盘映像以进行快速部署。ImageX可以使用 Windows 映像 (.wim) 文件复制到网络，或者还可以使用其他利用 .wim 映像的技术，如 Windows 安装程序、Windows 部署服务 (Windows DS) 以及系统管理服务器 (SMS) 操作系统功能部署包。&lt;!-- more --&gt;帮助文档\\&gt; imagex /help...",
    "created_at": "2018-06-29T14:38:39.000Z",
    "updated_at": "2018-09-15T09:37:22.000Z",
    "published_at": "2018-09-15T09:37:22.000Z",
    "format": "asl",
    "slug": "gud1gc",
    "last_editor": {
      "id": 103147,
      "type": "User",
      "login": "yinzhi",
      "name": "尹挚",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "followers_count": 9,
      "following_count": 5,
      "created_at": "2018-04-23T00:50:24.000Z",
      "updated_at": "2018-11-20T01:24:53.000Z",
      "_serializer": "v2.user"
    },
    "tags": [
      "计算机维护"
    ],
    "date": "2015-01-20 00:00:00 +0800",
    "body": "\n### <a name=\"wqiyvt\"></a>imagex.exe简介\n\nimagex.exe是一款用来捕获、修改和应用基于文件的磁盘映像以进行快速部署。ImageX可以使用 Windows 映像 (.wim) 文件复制到网络，或者还可以使用其他利用 .wim 映像的技术，如 Windows 安装程序、Windows 部署服务 (Windows DS) 以及系统管理服务器 (SMS) 操作系统功能部署包。\n\n<!-- more -->\n\n### <a name=\"ughyat\"></a>帮助文档\n\n```Bash\n\\> imagex /help\t\t#查看帮助文档\nImageX Tool for Windows\nCopyright (C) Microsoft Corp. All rights reserved.\nVersion: 6.1.7600.16385\n\nIMAGEX [Flags] /Operation [Parameter List]\n\n  Operation [ APPEND  | APPLY   | CAPTURE | DELETE  |\n              DIR     | EXPORT  | INFO    | SPLIT   |\n              MOUNT   | MOUNTRW | REMOUNT | UNMOUNT |\n              CLEANUP | COMMIT ]\n\nFor help on a specific operation type:\n  IMAGEX /Operation /?\n\nExamples:\n  IMAGEX /APPEND /?\n  IMAGEX /APPLY /?\n  IMAGEX /CAPTURE /?\n  IMAGEX /DELETE /?\n  IMAGEX /DIR /?\n  IMAGEX /EXPORT /?\n  IMAGEX /INFO /?\n  IMAGEX /SPLIT /?\n  IMAGEX /MOUNT /?\n  IMAGEX /MOUNTRW /?\n  IMAGEX /REMOUNT /?\n  IMAGEX /COMMIT /?\n  IMAGEX /UNMOUNT /?\n  IMAGEX /CLEANUP /?\n\nAll operations accept the following flags:\n  /SCROLL\n  /LOGFILE logfile.log\n\\>\n```\n\n### <a name=\"srozaf\"></a>安装系统需要使用的命令(这里采用wim镜像安装系统)\n\n* 检测wim镜像的完整性，并获取到wim镜像的系统版本系统：\n\n```Bash\n> imagex /info install.wim\t\t#查看\"install.wim\"的相关信息\n\nImageX Tool for Windows\nCopyright (C) Microsoft Corp. All rights reserved.\nVersion: 6.1.7600.16385\n\nWIM Information:\n----------------\nPath:        \\Windows8.1\\sources\\install.wim\nGUID:        {93bf56b4-8645-44b8-a3d3-b96aa7f508df}\n# Image Count 是重要信息\nImage Count: 1\nCompression: LZX\nPart Number: 1/1\nAttributes:  0xc\n             Integrity info\n             Relative path junction\n\n\nAvailable Image Choices:\n------------------------\n<WIM>\n  <TOTALBYTES>3457099927</TOTALBYTES>\n  <IMAGE INDEX=\"1\">\n    <DIRCOUNT>19524</DIRCOUNT>\n    <FILECOUNT>92795</FILECOUNT>\n    <TOTALBYTES>12855928858</TOTALBYTES>\n    <HARDLINKBYTES>5346880387</HARDLINKBYTES>\n    <CREATIONTIME>\n      <HIGHPART>0x01CF4298</HIGHPART>\n      <LOWPART>0x37D85CC6</LOWPART>\n    </CREATIONTIME>\n    <LASTMODIFICATIONTIME>\n      <HIGHPART>0x01CF4298</HIGHPART>\n      <LOWPART>0x74FBCEDF</LOWPART>\n    </LASTMODIFICATIONTIME>\n    <WIMBOOT>0</WIMBOOT>\n    <WINDOWS>\n      <ARCH>9</ARCH>\n      <PRODUCTNAME>Microsoft® Windows® Operating System</PRODUCTNAME>\n      <EDITIONID>Professional</EDITIONID>\n      <INSTALLATIONTYPE>Client</INSTALLATIONTYPE>\n      <SERVICINGDATA>\n        <GDRDUREVISION>20140317</GDRDUREVISION>\n        <PKEYCONFIGVERSION>6.3.9600.17031;2014-02-22T04:31:55Z</PKEYCONFIGVERSION>\n      </SERVICINGDATA>\n      <HAL>acpiapic</HAL>\n      <PRODUCTTYPE>WinNT</PRODUCTTYPE>\n      <PRODUCTSUITE>Terminal Server</PRODUCTSUITE>\n      <LANGUAGES>\n        <LANGUAGE>zh-CN</LANGUAGE>\n        <FALLBACK LANGUAGE=\"zh-CN\">en-US</FALLBACK>\n        <DEFAULT>zh-CN</DEFAULT>\n      </LANGUAGES>\n      <VERSION>\n        <MAJOR>6</MAJOR>\n        <MINOR>3</MINOR>\n        <BUILD>9600</BUILD>\n        <SPBUILD>17031</SPBUILD>\n        <SPLEVEL>0</SPLEVEL>\n      </VERSION>\n      <SYSTEMROOT>WINDOWS</SYSTEMROOT>\n    </WINDOWS>\n    <NAME>Windows 8.1 Pro</NAME>\n    <DESCRIPTION>Windows 8.1 Pro</DESCRIPTION>\n    <FLAGS>Professional</FLAGS>\n    <DISPLAYNAME>Windows 8.1 专业版</DISPLAYNAME>\n    <DISPLAYDESCRIPTION>Windows 8.1 专业版</DISPLAYDESCRIPTION>\n  </IMAGE>\n</WIM>\n\n\\>\n```\n\n* Image Count 即是该镜像包含的的系统各版本的计数，如旗舰版、专业版等。我们需要在后面的XML里面找到自己需要安装的系统版本对应的Count记录下来。\n* 解压install.wim镜像内的系统文件到对应的路径，既是完成安装系统文件的过程。\n\n```Bash\n\\> imagex /apply install.wim 1 c:\t#其中数字\"1\"就是刚刚记录下的Count\n```\n\n* 备份系统同样也能完成：\n\n```Bash\n#增量备份，即在“windows.wim”里添加子映像\n\\> imagex /append C: D:\\windows.wim \"windows(2)\"\n```\n\n* 完成了以上工作，基本的操作系统文件已经完成了复制过程，接下来我们则需要给新装的系统添加引导。只需要一条简单的命令，当然你也可以通过easybcd等工具来完成此过程。\n\n```Bash\n\\> bcdboot c:\\windows\n```\n\n### <a name=\"r7u2cu\"></a>小结\n\n1. imagex工具备份和还原的速度快，体积非常小。\n2. imagex工具在命令行下的语法多样，可以进行各种灵活的操作。\n3. 使用此方法非常适合直接在常用的操作系统上安装第二操作系统，并且速度十分可观，配合VHD安装多系统更是巧妙。\n\n"
  },
  {
    "title": "js自动化处理表单",
    "description": "date: 2015-01-07tags: [javascript, 自动化]我们在浏览网页时偶尔会碰到一些需要重复选择各种选项的尴尬局面，我们希望可以有一种工具可以帮助我们自动完成填表或者选择选卡项目。实现原理调用浏览器的控制台运行js脚本，从而达到自动填写表单和选择勾选项，以及自动提交等功能。&lt;!-- more --&gt;实现方法（例子）获取到表单元素，首先需要浏览到你需要操作的网页，通过浏览器的审查元素或者查看源代码可以获取到按钮/选项/输入框在文档中的位置。//获取表单对象 var...",
    "created_at": "2018-06-29T14:38:10.000Z",
    "updated_at": "2018-09-15T09:40:58.000Z",
    "published_at": "2018-09-15T09:40:58.000Z",
    "format": "asl",
    "slug": "wn7wdo",
    "last_editor": {
      "id": 103147,
      "type": "User",
      "login": "yinzhi",
      "name": "尹挚",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "followers_count": 9,
      "following_count": 5,
      "created_at": "2018-04-23T00:50:24.000Z",
      "updated_at": "2018-11-20T01:24:53.000Z",
      "_serializer": "v2.user"
    },
    "date": "2015-01-07 00:00:00 +0800",
    "tags": [
      "javascript",
      "自动化"
    ],
    "body": "\n我们在浏览网页时偶尔会碰到一些需要重复选择各种选项的尴尬局面，我们希望可以有一种工具可以帮助我们自动完成填表或者选择选卡项目。\n\n### <a name=\"ane9es\"></a>实现原理\n\n调用浏览器的控制台运行js脚本，从而达到自动填写表单和选择勾选项，以及自动提交等功能。\n\n<!-- more -->\n\n### <a name=\"wccbgv\"></a>实现方法（例子）\n\n* 获取到表单元素，首先需要浏览到你需要操作的网页，通过浏览器的审查元素或者查看源代码可以获取到按钮/选项/输入框在文档中的位置。\n\n```js\n//获取表单对象\nvar form = document.getElementsByTagName('form')[0];\nvar btn = document.getElementById('btn1');\n//获取选项列表\nvar selList = form.getElementsByTagName('select');\nvar username = document.getElementById('username');\nvar password = document.getElementById('password');\n```\n\n* 利用js进行自动选择选项和提交功能。(自动填表也可以如法炮制)\n\n```js\n//遍历，填写选项\nfor (var i = 0, len = selList.length; i < len; i++) {\n\tselList[i].options[1].selected = 'selected';\n\tif (1 == i) {\n\t\tselList[i].options[2].selected = 'selected';\n\t};\n};\n//自动填表\nusername.value = 'test';\npassword.value = 'test';\n//自动点击按钮\nbtn.click();\n}\n```\n\n### <a name=\"veydur\"></a>小结\n\n* 需要对html有基本的了解，才能快速地通过审查元素找到需要操作的DOM对象\n* 在一些带有iframe框架的网页，可以使用下面这条js语句获取iframe\n\n```js\nvar frame = window.frames[\"zhuti\"].document.getElementById('divJs');\n```\n\n* 在demo网页上通过浏览器控制台运行可以的显示效果\n\n```js\n(function juadge(num) {\n\t//获取表单对象\n\tvar form = document.getElementsByTagName('form')[0];\n\tvar btn = document.getElementById('btn1');\n\t//获取选项列表\n\tvar selList = form.getElementsByTagName('select');\n\tvar username = document.getElementById('username');\n\tvar password = document.getElementById('password');\n\n\tif (1 == num) {\n\t   for (var i = 0, len = selList.length; i < len; i++) {\n\t   \t\t//下标i为第i个选项，后面的下标1则是需要选取第几个选项\n\t    \tselList[i].options[1].selected = 'selected';\n\t   }\n\n\t   //自动填表，设置用户名和密码\n\t   username.value = 'test';\n\t   password.value = 'test';\n\n\t   //自动点击按钮提交\n\t   btn.click();\n\t} else {\n\t   for (var i = 0, len = selList.length; i < len; i++) {\n\t      selList[i].options[0].selected = 'selected';\n\t   }\n\t   username.value = \"\";\n\t   password.value = \"\";\n\t}\n})(num);\n//num填写1为自动处理\n//num填写0为清除表单\n```\n\n[查看demo](http://7u2liq.com1.z0.glb.clouddn.com/blog/demo/js自动处理表单/)\n\n### <a name=\"v540ts\"></a>demo源代码\n\n```html\n<!DOCTYPE html>\n<html>\n   <head>\n      <title>js自动处理表单</title>\n      <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n      <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\n      <!-- 引入 Bootstrap -->\n      <link href=\"http://apps.bdimg.com/libs/bootstrap/3.3.0/css/bootstrap.min.css\" rel=\"stylesheet\">\n\n      <!-- HTML5 Shim 和 Respond.js 用于让 IE8 支持 HTML5元素和媒体查询 -->\n      <!-- 注意： 如果通过 file://  引入 Respond.js 文件，则该文件无法起效果 -->\n      <!--[if lt IE 9]>\n         <script src=\"https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js\"></script>\n         <script src=\"https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js\"></script>\n      <![endif]-->\n   </head>\n   <body>\n      <div class=\"container\">\n         <h1>js自动处理表单</h1>\n         <form role=\"form\">\n            <div class=\"form-group\">\n               <p>选项1</p>\n               <select class=\"form-control input-sm\">\n                  <option value=\"\">默认选择</option>\n                  <option value=\"\">1</option>\n                  <option value=\"\">2</option>\n                  <option value=\"\">3</option>\n               </select>\n            </div>\n            <div class=\"form-group\">\n               <p>选项2</p>\n               <select class=\"form-control input-sm\">\n                  <option value=\"\">默认选择</option>\n                  <option value=\"\">1</option>\n                  <option value=\"\">2</option>\n                  <option value=\"\">3</option>\n               </select>\n            </div>\n            <div class=\"form-group\">\n               <p>选项3</p>\n               <select class=\"form-control input-sm\">\n                  <option value=\"\">默认选择</option>\n                  <option value=\"\">1</option>\n                  <option value=\"\">2</option>\n                  <option value=\"\">3</option>\n               </select>\n            </div>\n            <div class=\"form-group\">\n               <p>选项4</p>\n               <select class=\"form-control input-sm\">\n                  <option value=\"\">默认选择</option>\n                  <option value=\"\">1</option>\n                  <option value=\"\">2</option>\n                  <option value=\"\">3</option>\n               </select>\n            </div>\n            <div class=\"form-group\">\n               <p>选项5</p>\n               <select class=\"form-control input-sm\">\n                  <option value=\"\">默认选择</option>\n                  <option value=\"\">1</option>\n                  <option value=\"\">2</option>\n                  <option value=\"\">3</option>\n               </select>\n            </div>\n\n            <div class=\"form-group\">\n               <label for=\"firstname\" class=\"col-sm-1 control-label\">用户名:</label>\n               <div class=\"col-sm-11\">\n                  <input type=\"text\" class=\"form-control\" id=\"username\"\n                     placeholder=\"请输入用户名\">\n               </div>\n            </div> \n\n            <div class=\"form-group\">\n               <label for=\"lastname\" class=\"col-sm-1 control-label\">密码：</label>\n               <div class=\"col-sm-11\">\n                  <input type=\"password\" class=\"form-control\" id=\"password\" placeholder=\"请输入密码\">\n               </div>\n            </div> \n\n            <div class=\"form-group\">\n               <button type=\"button\" class=\"btn btn-primary\" id=\"btn1\" onclick=\"javascript:sub()\">提交</button>\n               <button type=\"button\" class=\"btn btn-success\" id=\"btn2\" onclick=\"javascript:juadge(1)\">自动填表</button>\n               <button type=\"button\" class=\"btn btn-warning\" id=\"btn3\" onclick=\"javascript:juadge(0)\">恢复默认</button>\n            </div>\n         </form>\n      </div>\n      <script type=\"text/javascript\">\n         function sub() {\n            alert(\"Submit\");\n         }\n\n         function juadge(num) {\n            //获取表单对象\n            var form = document.getElementsByTagName('form')[0];\n            var btn = document.getElementById('btn1');\n            //获取选项列表\n            var selList = form.getElementsByTagName('select');\n            var username = document.getElementById('username');\n            var password = document.getElementById('password');\n\n            if (1 == num) {\n               for (var i = 0, len = selList.length; i < len; i++) {\n                  selList[i].options[1].selected = 'selected';\n                  if (1 == i) {\n                     selList[i].options[2].selected = 'selected';\n                  };\n               }\n\n               //自动填表\n               username.value = \"test\";\n               password.value = \"test\";\n               //自动点击按钮\n               btn.click();\n            } else {\n               for (var i = 0, len = selList.length; i < len; i++) {\n                  selList[i].options[0].selected = 'selected';\n               }\n               username.value = \"\";\n               password.value = \"\";\n            }\n         };\n\n      </script>\n\n   </body>\n</html>\n```\n\n"
  },
  {
    "title": "JavaScript的一些定位属性",
    "description": "tags: [javascript]date: 2015-01-20Javascript 定位属性clientHeight\\clientWidth 可见窗口除去margin和border之后的高度\\宽度offsetHeight\\offsetWidth clientHeight的基础上加border和滚动条的高度\\宽度&lt;!-- more --&gt;scrollHeight\\scrollWidth 元素内容的实际高度（内容多了可能会改变对象的实际宽度）clientTop\\clientLeft...",
    "created_at": "2018-06-29T14:37:31.000Z",
    "updated_at": "2018-09-15T08:08:26.000Z",
    "published_at": "2018-09-15T08:08:26.000Z",
    "format": "asl",
    "slug": "mdfepb",
    "last_editor": {
      "id": 103147,
      "type": "User",
      "login": "yinzhi",
      "name": "尹挚",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "followers_count": 9,
      "following_count": 5,
      "created_at": "2018-04-23T00:50:24.000Z",
      "updated_at": "2018-11-20T01:24:53.000Z",
      "_serializer": "v2.user"
    },
    "tags": [
      "javascript"
    ],
    "date": "2015-01-20 00:00:00 +0800",
    "body": "\n### <a name=\"qb03hx\"></a>Javascript 定位属性\n\n* clientHeight\\clientWidth\n    可见窗口除去margin和border之后的高度\\宽度\n\n* offsetHeight\\offsetWidth\n    clientHeight的基础上加border和滚动条的高度\\宽度\n\n<!-- more -->\n\n* scrollHeight\\scrollWidth\n    元素内容的实际高度（内容多了可能会改变对象的实际宽度）\n\n* clientTop\\clientLeft\n    子元素margin之后父元素padding之前的高度\\宽度\n\n* offsetTop\\offsetLeft\n    该元素的上border的上边缘到该元素的offsetParent的上border内边缘的垂直\\水平距离\n\n* scrollTop\\scrollLeft\n    对象的最顶部（左侧）到对象在当前窗口显示的范围内的顶边（左边）的距离，即是在出现了纵向滚动条的情况下，滚动条拉动的距离\n\n关于offsetParent，不同的浏览器有不同的实现算法，其中一种常见布局在各种浏览器中 offsetParent 是一样的：\n外层元素div的position计算值是relative、absolute时，内层元素div的offsetParent 总是外层元素div。\n\n### <a name=\"8btqgx\"></a>下面是一个简单的demo页面\n\n[查看demo](http://7u2liq.com1.z0.glb.clouddn.com/blog/demo/JS定位属性/)\n\n"
  },
  {
    "title": "Javascript ajax获取xml",
    "description": "tags: [javascript, xml]date: 2015-02-12ajax简介AJAX = 异步 JavaScript 和 XMLAJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术AJAX 是一种用于创建快速动态网页的技术&lt;!-- more --&gt;ajax操作xml可以快速建立轻量级的动态网站,下面是实例：查看demo/js/state.jsfunction loadXMLDoc(url) { \tvar xmlhttp; \tvar content,tr,temp...",
    "created_at": "2018-06-29T14:36:50.000Z",
    "updated_at": "2018-09-15T08:08:53.000Z",
    "published_at": "2018-09-15T08:08:53.000Z",
    "format": "asl",
    "slug": "ki4660",
    "last_editor": {
      "id": 103147,
      "type": "User",
      "login": "yinzhi",
      "name": "尹挚",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "followers_count": 9,
      "following_count": 5,
      "created_at": "2018-04-23T00:50:24.000Z",
      "updated_at": "2018-11-20T01:24:53.000Z",
      "_serializer": "v2.user"
    },
    "tags": [
      "javascript",
      "xml"
    ],
    "date": "2015-02-12 00:00:00 +0800",
    "body": "\n### <a name=\"drxfnz\"></a>ajax简介\n\n* AJAX = 异步 JavaScript 和 XML\n* AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术\n* AJAX 是一种用于创建快速动态网页的技术\n\n<!-- more -->\n\n### <a name=\"lucpnp\"></a>ajax操作xml可以快速建立轻量级的动态网站,下面是实例：\n\n[查看demo](http://7u2liq.com1.z0.glb.clouddn.com/blog/demo/ajax/html/)\n\n* /js/state.js\n\n```js\nfunction loadXMLDoc(url) {\n\tvar xmlhttp;\n\tvar content,tr,temp,data;\n\t// 创建请求对象\n\tif (window.XMLHttpRequest) {\n\t\t// code for IE7+, Firefox, Chrome, Opera, Safari\n\t\txmlhttp = new XMLHttpRequest();\n\t} else {\n\t\t// code for IE6, IE5\n\t\txmlhttp = new ActiveXObject(\"Microsoft.XMLHTTP\");\n\t}\n\t// 处理返回的请求，其中返回的格式为XML\n\txmlhttp.onreadystatechange = function() {\n\t\t// 注意当xml为本地文件时，xmlhttp.status一直保持为0\n\t\tif (xmlhttp.readyState == 4 && xmlhttp.status == 200) {\n\t\t\tvar List = xmlhttp.responseXML.documentElement.getElementsByTagName(\"CONTACT\");\n\t\t\tfor (var i = 0; i < List.length ; i++) {\n\t\t\t\tcontent = document.getElementById('content-box');\n\t\t\t\ttr = document.createElement('tr');\n\t\t\t\ttemp = \"<td>\" + (i+1) + \"</td>\";\n\t\t\t\tdata = List[i].getElementsByTagName(\"NAME\");\n\t\t\t\t{\n\t\t\t\t\ttry {\n\t\t\t\t\t\ttemp += \"<td>\" + data[0].firstChild.nodeValue + \"</td>\";\n\t\t\t\t\t} catch (er) {\n\t\t\t\t\t\ttemp += \"<td> </td>\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdata = List[i].getElementsByTagName(\"PHONE\");\n\t\t\t\t{\n\t\t\t\t\ttry {\n\t\t\t\t\t\ttemp += \"<td>\" + data[0].firstChild.nodeValue + \"</td>\";\n\t\t\t\t\t} catch (er) {\n\t\t\t\t\t\ttemp += \"<td> </td>\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdata = List[i].getElementsByTagName(\"EMAIL\");\n\t\t\t\t{\n\t\t\t\t\ttry {\n\t\t\t\t\t\ttemp += \"<td>\" + data[0].firstChild.nodeValue + \"</td>\";\n\t\t\t\t\t} catch (er) {\n\t\t\t\t\t\ttemp += \"<td> </td>\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdata = List[i].getElementsByTagName(\"QQ\");\n\t\t\t\t{\n\t\t\t\t\ttry {\n\t\t\t\t\t\ttemp += \"<td>\" + data[0].firstChild.nodeValue + \"</td>\";\n\t\t\t\t\t} catch (er) {\n\t\t\t\t\t\ttemp += \"<td> </td>\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttr.innerHTML = temp;\n\t\t\t\tcontent.appendChild(tr);\n\t\t\t}\n\n\t\t}\n\t}\n\txmlhttp.open(\"GET\", url, true);\n\txmlhttp.send();\n}\n\n```\n\n* /html/index.html\n\n```html\n<!DOCTYPE html>\n<html>\n   <head>\n      <title>AJAX解析</title>\n      <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n      <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n      <!-- 引入 Bootstrap -->\n      <link href=\"http://apps.bdimg.com/libs/bootstrap/3.3.0/css/bootstrap.min.css\" rel=\"stylesheet\">\n\n      <!-- HTML5 Shim 和 Respond.js 用于让 IE8 支持 HTML5元素和媒体查询 -->\n      <!-- 注意： 如果通过 file://  引入 Respond.js 文件，则该文件无法起效果 -->\n      <!--[if lt IE 9]>\n         <script src=\"https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js\"></script>\n         <script src=\"https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js\"></script>\n      <![endif]-->\n   </head>\n   <body>\n      <div class=\"container\">\n         <h1 class=\"text-center\"><button class=\"btn btn-primary\" onclick=\"loadXMLDoc('../xml/data.xml')\">加载AJAX</button></h1>\n         <!-- main body start -->\n         <div class=\"col-md-12\">\n            <table class=\"table table-striped table-bordered\">\n               <thead>\n                 <tr>\n                   <th>#</th>\n                   <th>姓名</th>\n                   <th>手机号</th>\n                   <th>邮箱</th>\n                   <th>QQ</th>\n                 </tr>\n               </thead>\n               <tbody id=\"content-box\">\n               </tbody>\n            </table>\n         </div>\n      </div>\n      <!-- jQuery (Bootstrap 的 JavaScript 插件需要引入 jQuery) -->\n      <script src=\"https://code.jquery.com/jquery.js\"></script>\n      <!-- 包括所有已编译的插件 -->\n      <script src=\"../js/state.js\"></script>\n   </body>\n</html>\n```\n\n* /xml/data.xml\n\n```xml\n<!--  Contacts List -->\n<LIST>\n\t<CONTACT>\n\t\t<NAME>qqqq</NAME>\n\t\t<PHONE>13322332233</PHONE>\n\t\t<EMAIL>qq@admin.com</EMAIL>\n\t\t<QQ>123456</QQ>\n\t</CONTACT>\n\t<CONTACT>\n\t\t<NAME>tttt</NAME>\n\t\t<PHONE>13322332233</PHONE>\n\t\t<EMAIL>qq@admin.com</EMAIL>\n\t\t<QQ>123456</QQ>\n\t</CONTACT>\n\t<CONTACT>\n\t\t<NAME>gggg</NAME>\n\t\t<PHONE>13322332233</PHONE>\n\t\t<EMAIL>qq@admin.com</EMAIL>\n\t\t<QQ>123456</QQ>\n\t</CONTACT>\n\t<CONTACT>\n\t\t<NAME>aaaa</NAME>\n\t\t<PHONE>13322332233</PHONE>\n\t\t<EMAIL>qq@admin.com</EMAIL>\n\t\t<QQ>123456</QQ>\n\t</CONTACT>\n\t<CONTACT>\n\t\t<NAME>xxxx</NAME>\n\t\t<PHONE>13322332233</PHONE>\n\t\t<EMAIL>qq@admin.com</EMAIL>\n\t\t<QQ>123456</QQ>\n\t</CONTACT>\n\t<CONTACT>\n\t\t<NAME>zzzz</NAME>\n\t\t<PHONE>13322332233</PHONE>\n\t\t<EMAIL>qq@admin.com</EMAIL>\n\t\t<QQ>123456</QQ>\n\t</CONTACT>\n</LIST>\n```\n\n"
  },
  {
    "title": "Javascript 设计模式之单例模式",
    "description": "tags: [javascript, 设计模式]date: 2017-09-10 23:28:00单例模式是一个非常典型的设计模式，保证一个类只有唯一实例，并且提供单一的访问点。单例的对象不同于静态类，我们可以延迟单例对象的初始化，通常这种情况发生在我们需要等待加载创建单例的依赖。单例的特性全局唯一实例单一的访问入口&lt;!-- more --&gt;如何创建一个单例？接下来我将以设计一个全局的Loading状态的实例以渐入佳境。你不是真正的单例？var createLoading = function...",
    "created_at": "2018-06-29T14:36:25.000Z",
    "updated_at": "2018-09-15T09:43:07.000Z",
    "published_at": "2018-09-15T09:43:07.000Z",
    "format": "asl",
    "slug": "xqgy6w",
    "last_editor": {
      "id": 103147,
      "type": "User",
      "login": "yinzhi",
      "name": "尹挚",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "followers_count": 9,
      "following_count": 5,
      "created_at": "2018-04-23T00:50:24.000Z",
      "updated_at": "2018-11-20T01:24:53.000Z",
      "_serializer": "v2.user"
    },
    "tags": [
      "javascript",
      "设计模式"
    ],
    "date": "2017-09-10 23:28:00 +0800",
    "body": "\n单例模式是一个非常典型的设计模式，保证一个类只有唯一实例，并且提供单一的访问点。单例的对象不同于静态类，我们可以延迟单例对象的初始化，通常这种情况发生在我们需要等待加载创建单例的依赖。\n\n#### <a name=\"x86ogl\"></a>单例的特性\n\n* 全局唯一实例\n* 单一的访问入口\n\n<!-- more -->\n\n#### <a name=\"b3t1da\"></a>如何创建一个单例？\n\n接下来我将以设计一个全局的Loading状态的实例以渐入佳境。\n\n> 你不是真正的单例？\n\n```javascript\nvar createLoading = function(){\n\tvar LOADING_TPL =\n    '<div class=\"loading-container\">' +\n    '<div class=\"loading\">' +\n    '</div>' +\n    '</div>';\n\tvar loading = document.createElement('div');\n   loading.innerText = LOADING_TPL;\n   \n   return document.body.appendChild(loading);\t// 创建一个loading实例\n}\n```\n\nExcuse me？这就是传说中的单例模式吗？\n\n#### <a name=\"6hokkg\"></a>典型应用场景\n\n* 惰性单例：在合适的时候才创建对象，如缓存对象等。\n* 单例服务：Angular 1.x 的服务实例\n* 单例组件：全局唯一的遮罩层、弹窗等\n\n#### <a name=\"pdxpeh\"></a>小结\n\n单例模式能够我们能在全局的上下文环境下获取唯一的对象，这种特性适用于多次调用的对象。\n"
  },
  {
    "title": "如何在HTML内包含模板文件",
    "description": "tags: [html, javascript]date: 2015-08-09题记最近项目开发使用了全新的架构（RequireJS+AngularJS+IonicUI），类似的前端MVVM框架已经深入人心，因此也试着在项目之余写一点小代码实现部分功能。下面我们将用原生的Javascript实现一个在HTML内引入HTML文件的简单小组件。言归正传，我们要实现的功能就是在一个HTML内引用其他的HTML模板文件。例如以下场景：应用的多个页面需要复用一个header...",
    "created_at": "2018-06-29T14:35:41.000Z",
    "updated_at": "2018-09-15T08:11:13.000Z",
    "published_at": "2018-09-15T08:11:13.000Z",
    "format": "asl",
    "slug": "yg79mz",
    "last_editor": {
      "id": 103147,
      "type": "User",
      "login": "yinzhi",
      "name": "尹挚",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "followers_count": 9,
      "following_count": 5,
      "created_at": "2018-04-23T00:50:24.000Z",
      "updated_at": "2018-11-20T01:24:53.000Z",
      "_serializer": "v2.user"
    },
    "tags": [
      "html",
      "javascript"
    ],
    "date": "2015-08-09 00:00:00 +0800",
    "body": "\n## <a name=\"1dtfnz\"></a>题记\n\n最近项目开发使用了全新的架构（RequireJS+AngularJS+IonicUI），类似的前端MVVM框架已经深入人心，因此也试着在项目之余写一点小代码实现部分功能。下面我们将用原生的Javascript实现一个在HTML内引入HTML文件的简单小组件。\n\n言归正传，我们要实现的功能就是在一个HTML内引用其他的HTML模板文件。例如以下场景：应用的多个页面需要复用一个header，而我们希望只对其进行一次编辑和修改就可以应用于所有页面，因为我们可以将header的内容作为一个模板，其他页面只需要调用这个模板。\n\n<!-- more -->\n\n<em>在后端的模板引擎内我们可以直接使用</em><em><code>include</code></em><em>类似的语句包含其他的模板，在一些SPA(Single Page APP)也是利用了类似于</em><em><code>ng-include</code></em><em>的写法复用HTML模板</em>\n\n### <a name=\"onvkyr\"></a>设计思路：\n\n* HTML标签：添加`include-html`属性，用于置入引用的HTML模板的URL\n\n```html\n<div include-html=\"./header.html\"></div>\n```\n\n* 获取所有URL的值\n\n```js\nvar dom = document.getElementsByTagName('*');\nfor (var i = 0; i < dom.length; i++) {\n\tvar bakNode = dom[i];\n\turl = bakNode.getAttribute('include-html');\n\tif (!check(url)) continue;\n}\n```\n\n* 发送GET请求获取URL指向的模板页面并进行处理\n\n```js\n/**\n *\thtml文件包含器\n *\t调用方式：DOM内插入属性'include-html=\"路径\"'\n */\nvar includeHandle = function() {\n\tvar dom, // DOM节点\n\t\turl; // 文件路径\n\tdom = document.getElementsByTagName('*');\n\tfor (var i = 0; i < dom.length; i++) {\n\t\tvar bakNode = dom[i];\n\t\turl = bakNode.getAttribute('include-html');\n\t\tif (!check(url)) continue;\n\t\tvar node = bakNode;\n\t\tnode.removeAttribute('include-html');\n\t\tloadHTML('GET', url, true, function(result) {\n\t\t\tnode.innerHTML = result;\n\t\t\t// 递归调用\n\t\t\t// includeHandle();\n\t\t});\n\t}\n}\n\n/**\n *\tXMLHttpRequest Get Html Content\n *\t@param\t{String} method - 方法\n *\t@param\t{String}\turl\t- 路径\n *\t@param\t{Bool}\tasync\t- 异步选项\n */\nvar loadHTML = function(method, url, async, callback) {\n\tvar result = '';\n\tif (!check(method)) var method = 'GET';\n\tif (!check(async)) var async = false;\n\tvar xhttp; // HTTPRequest\n\tif (window.XMLHttpRequest) {\n\t\txhttp = new XMLHttpRequest();\n\t} else {\n\t\txhttp = new ActiveXObject('Microsoft.XMLHTTP')\n\t}\n\txhttp.onreadystatechange = function() {\n\t\tif (xhttp.readyState === 4 && xhttp.status === 0) {\n\t\t\tresult = xhttp.responseText;\n\t\t\tcallback(result);\n\t\t}\n\t}\n\txhttp.open(method, url, async);\n\txhttp.send();\n}\n```\n\n* 递归调用 => 嵌套调用\n\n这里还需要进行算法优化，借着午后小憩的时间暂且先完成此DEMO，后继完善。\n\n### <a name=\"551zyg\"></a>完整DEMO\n\n1. index.html\n\n```html\n<!DOCTYPE html>\n<html>\n\t<head>\n\t\t<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n\t</head>\n\t<body>\n\t\t<div include-html=\"test.html\"></div>\n\t\t<section>test</section>\n\t\t<script type=\"text/javascript\" src=\"demo.js\"></script>\n\t</body>\n</html>\n```\n\n1. index.html\n\n```html\n<!DOCTYPE html>\n<header>\n\t<ul class=\"menu\">\n\t\t<li>1111</li><li>2222</li><li>3333</li>\n\t</ul>\n</header>\n```\n\n1. demo.js\n\n```js\n/**\n *  数据校验\n */\nvar check = function(data) {\n\tif (typeof(data) === undefined || data === null || data === '' || data === undefined) return false;\n\treturn true;\n}\n\n/**\n *\tXMLHttpRequest Get Html Content\n *\t@param\t{String} method - 方法\n *\t@param\t{String}\turl\t- 路径\n *\t@param\t{Bool}\tasync\t- 异步选项\n */\nvar loadHTML = function(method, url, async, callback) {\n  var result = '';\n  if (!check(method)) var method = 'GET';\n  if (!check(async)) var async = false;\n  var xhttp; // HTTPRequest\n  if (window.XMLHttpRequest) {\n    xhttp = new XMLHttpRequest();\n  } else {\n    xhttp = new ActiveXObject('Microsoft.XMLHTTP')\n  }\n  xhttp.onreadystatechange = function() {\n    if (xhttp.readyState === 4 && xhttp.status === 0) {\n      result = xhttp.responseText;\n      callback(result);\n    }\n  }\n  xhttp.open(method, url, async);\n  xhttp.send();\n}\n\n/**\n *\thtml文件包含器\n *\t调用方式：DOM内插入属性'include-html=\"路径\"'\n */\nvar includeHandle = function() {\n\tvar dom, // DOM节点\n\t\turl; // 文件路径\n\tdom = document.getElementsByTagName('*');\n\tfor (var i = 0; i < dom.length; i++) {\n\t\tvar bakNode = dom[i];\n\t\turl = bakNode.getAttribute('include-html');\n\t\tif (!check(url)) continue;\n\t\tvar node = bakNode;\n\t\tnode.removeAttribute('include-html');\n\t\tloadHTML('GET', url, true, function(result) {\n\t\t\tnode.innerHTML = result;\n\t\t\t// 递归调用\n\t\t\t// includeHandle();\n\t\t});\n\t}\n}\nincludeHandle();\n```\n\n"
  },
  {
    "title": "Javascript之window对象",
    "description": "tags: [javascript]date: 2015-03-01说到window对象我们不得不提及BOM，BOM是browser object model的缩写，正如其名为浏览器对象模型。BOM提供了独立于内容而与浏览器窗口进行交互的对象，BOM由一系列相关的对象组成，其中最主要对象为window，下面我们将分类讲解window对象。概述window对象是BOM顶层(核心对象)，其他对象均为window对象延伸拓展，成为其子对象。直接调用其子对象可以不指明window...",
    "created_at": "2018-06-29T14:33:52.000Z",
    "updated_at": "2018-09-15T08:09:48.000Z",
    "published_at": "2018-09-15T08:09:48.000Z",
    "format": "asl",
    "slug": "gh8736",
    "last_editor": {
      "id": 103147,
      "type": "User",
      "login": "yinzhi",
      "name": "尹挚",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "followers_count": 9,
      "following_count": 5,
      "created_at": "2018-04-23T00:50:24.000Z",
      "updated_at": "2018-11-20T01:24:53.000Z",
      "_serializer": "v2.user"
    },
    "tags": [
      "javascript"
    ],
    "date": "2015-03-01 00:00:00 +0800",
    "body": "\n说到window对象我们不得不提及BOM，BOM是browser object model的缩写，正如其名为浏览器对象模型。BOM提供了独立于内容而与浏览器窗口进行交互的对象，BOM由一系列相关的对象组成，其中最主要对象为window，下面我们将分类讲解window对象。\n\n### <a name=\"i5qgoi\"></a>概述\n\nwindow对象是BOM顶层(核心对象)，其他对象均为window对象延伸拓展，成为其子对象。直接调用其子对象可以不指明window对象，其子对象或者函数的作用域为全局（我们可以在局部的作用域定义window.variable将变量提升为全局变量）。接下来我们将从其子对象和函数两方面刨析。\n\n<!-- more -->\n\n[w3school对window对象的叙述](http://www.w3school.com.cn/jsref/dom_obj_window.asp)\n\n```js\n// true\nwindow.navigator === navigator;\n```\n\n### <a name=\"3ibpel\"></a>self对象\n\nself对象与window对象完全一致，self通常用于确认在当前窗口内。\n\n```js\n// true\nwindow.self === window;\n// true\nself.self === self;\n```\n\n### <a name=\"h3rstg\"></a>子对象(下面对于子对象函数的描述均省略显示使用window对象)\n\n\n\n![image.png | left | 525x501](https://cdn.yuque.com/yuque/0/2018/png/103147/1530282924354-52404bad-0b55-42bf-b181-09641b534884.png \"\")\n\n\n\n1、window.frames[]\n如果文档包含框架（frame 或 iframe 标签），浏览器会为 HTML 文档创建一个 window 对象，并为每个框架创建一个额外的 window 对象。通过frames[name][或frames.name](http://xn--frames-o06l.name)（name为框架的name）获取框架的window对象。\n\n*注释：没有应用于 window 对象的公开标准，不过所有浏览器都支持该对象。*\n\ntest.html\n\n```html\n<html>\n<head>\n\t<title>test</title>\n</head>\n<body>\n\t<p>test</p>\n\t<iframe src=\"./test.html\" name=\"myFrame\"></iframe>\n\t<script type=\"text/javascript\">\n\t\twindow.onload = function () {\n\t\t\tconsole.log(frames[\"myFrame\"]);\n\t\t}\n\t</script>\n</body>\n</html>\n```\n\n获取框架数量\n\n```js\n// 无框架则为0\nwindow.length\n```\n\n返回父对象\n\n```js\n// true\nframes[\"myFrame\"].parent === window;\n```\n\n返回顶层元素\n\n```js\n// true\nframes[\"myFrame\"].top === window;\n```\n\n2、window.navigator(只读引用)\n\nNavigator 对象包含有关浏览器的信息。\n\n属性 | 描述\nappCodeName | 返回浏览器的代码名。\nappName | 返回浏览器的名称。\nuserAgent | 返回由客户机发送服务器的 user-agent 头部的值。\nappVersion | 返回浏览器的平台和版本信息。\nplatform | 返回运行浏览器的操作系统平台。\nappMinorVersion\t| 返回浏览器的次级版本。\nbrowserLanguage | 返回当前浏览器的语言。\ncookieEnabled | 返回指明浏览器中是否启用 cookie 的布尔值。\ncpuClass | 返回浏览器系统的 CPU 等级。\nonLine | 返回指明系统是否处于脱机模式的布尔值。\nsystemLanguage | 返回 OS 使用的默认语言。\nuserLanguage | 返回 OS 的自然语言设置。\n\n---add-in\ngeolocation | 返回地理位置信息\n\n3、window.screen(只读引用)\n\nScreen 对象中存放着有关显示浏览器屏幕的信息。JavaScript 程序将利用这些信息来优化它们的输出，以达到用户的显示要求。\n\n属性 | 描述\navailHeight | 返回显示屏幕的高度 (除 Windows 任务栏之外)。\navailWidth | 返回显示屏幕的宽度 (除 Windows 任务栏之外)。\nbufferDepth | 设置或返回调色板的比特深度。\ncolorDepth | 返回目标设备或缓冲器上的调色板的比特深度。\ndeviceXDPI | 返回显示屏幕的每英寸水平点数。\ndeviceYDPI | 返回显示屏幕的每英寸垂直点数。\nfontSmoothingEnabled | 返回用户是否在显示控制面板中启用了字体平滑。\nheight | 返回显示屏幕的高度。\nlogicalXDPI | 返回显示屏幕每英寸的水平方向的常规点数。\nlogicalYDPI | 返回显示屏幕每英寸的垂直方向的常规点数。\npixelDepth | 返回显示屏幕的颜色分辨率（比特每像素）。\nupdateInterval | 设置或返回屏幕的刷新率。\nwidth | 返回显示器屏幕的宽度。\n\n4、window.location\nLocation 对象包含有关当前 URL 的信息。\n\n属性 | 描述\nhash | 设置或返回从井号 (#) 开始的 URL（锚）。\nhost | 设置或返回主机名和当前 URL 的端口号。\nhostname | 设置或返回当前 URL 的主机名。\nhref | 设置或返回完整的 URL。\npathname | 设置或返回当前 URL 的路径部分。\nport | 设置或返回当前 URL 的端口号。\nprotocol | 设置或返回当前 URL 的协议。\nsearch | 设置或返回从问号 (?) 开始的 URL（query部分）。\n\n属性 | 描述\nassign() | 加载新的文档。\nreload() | 重新加载当前文档。\nreplace() | 用新的文档替换当前文档。\n\n5、window.history(只读引用)\nHistory 对象包含用户（在浏览器窗口中）访问过的 URL。*是一个类似于栈的数据结构*\n\n属性 | 描述\nlength | 返回浏览器历史列表中的 URL 数量。\n\n函数 | 描述\nback() | 后退(history列表上一个URL)\nforward() | 前进(history列表下一个URL)\ngo() | 加载history列表中某个一个URL\n6、window.document\n\n### <a name=\"14gbaw\"></a>函数\n\n1、窗体控制函数\n\n* moveBy()\n    可相对窗口的当前坐标把它移动指定的像素。\n* moveTo()\n    把窗口的左上角移动到一个指定的坐标。\n\n```js\n// 右移x，下移y\nwindow.moveBy(x,y);\n\n// 直接到(x, y)坐标\nwindow.moveTo(x,y);\n```\n\n* resizeBy()\n    按照指定的像素调整窗口的大小。\n* resizeTo()\n    把窗口的大小调整到指定的宽度和高度。\n\n```js\n// 窗口宽度增加width，高度增加height\nresizeBy(width,height);\n// 窗口宽度设置为width，高度设置为height\nresizeTo(width,height);\n```\n\n2、滚动轴控制函数\n\n* scrollTo()\n    按照指定的像素值来滚动内容。\n* scrollBy()\n    把内容滚动到指定的坐标。\n\n```js\n// 向右滚动xs，向下滚动ys\nscrollBy(xs, ys);\n// 滚动到(xs，ys)\nscrollTo(xs, ys);\n```\n\n3、窗体焦点控制函数\n*腾讯的在线笔试似乎就是用这个防止作弊的(切换窗口)*\n\n* focus()\n    将键盘焦点赋予某一窗口。\n* blur()\n    把键盘焦点从顶层窗口移开。\n\n4、 新建窗体函数\n\n* open()\n    open() 方法用于打开一个新的浏览器窗口或查找一个已命名的窗口。[参考文档](http://www.w3school.com.cn/jsref/met_win_open.asp)\n* close()\n    close() 方法用于关闭浏览器窗口。\n\n```js\n// 打开窗口\nvar testWin = window.open(\"http://www.w3school.com.cn\",\"_blank\",\"toolbar=yes, location=yes, directories=no, status=no, menubar=yes, scrollbars=yes, resizable=no, copyhistory=yes, width=400, height=400\");\n\n// 关闭窗口\ntestWin.close;\n```\n\n5、对话框函数\n\n* alert()\n    显示带有一段消息和确认按钮的警告框。\n* confirm()\n    显示带有一段消息以及确认按钮和取消按钮的对话框。返回值为（确认按钮 ？ true : false）\n* prompt()\n    显示带有一段消息以及输入框、确认按钮和取消按钮的对话框。\n    *返回值为：输入的字符串或者null（取消按钮）*\n\n```js\n// alert()\nalert('hello');\n\n// confirm()\nconfirm('确认吗？') ? console.log('您点击了确认') : console.log('您点击了取消');\n\n// prompt\nvar string = prompt('请输入学号');\nstring !== null ? console.log('学号是' + string) : console.log('您点击了取消'');\n```\n\n6、时间等待和间隔函数\n\n* setTimeout()/clearTimeout()\n    按照指定的周期（以毫秒计）来调用函数或计算表达式 / 取消前者设定的计时器\n* setInterval/clearInterval()\n    在指定的毫秒数后调用函数或计算表达式 / 取消前者设定的计时器\n\n### <a name=\"bz4aqn\"></a>其他属性\n\n1、状态栏属性\n\n* window.defaultStatus\n    设置或返回窗口状态栏中的默认文本。\n* window.status\n    设置窗口状态栏的文本。\n\n2、窗口大小\n\n* innerHeight\n    页面可视化区域的高度（包含滚动条）\n* innerWidth\n    页面可视化区域的宽度（包含滚动条）\n* outerHeight\n    窗口可视化区域的高度（包含页面可视化区域和浏览器状态栏、工具栏等，即屏幕高度减去任务栏的高度）\n* outerWidth\n    窗口可视化区域的宽度（解释同上）\n\n3、位置偏移\n\n* pageXOffset\n    设置或返回当前页面相对于窗口显示区左上角的 X 位置。\n* pageYOffset\n    设置或返回当前页面相对于窗口显示区左上角的 Y 位置。\n* screenLeft / screenTop / screenX / screenY\n\n*只读整数。声明了窗口的左上角在屏幕上的的 x 坐标和 y 坐标。IE、Safari 和 Opera 支持 screenLeft 和 screenTop，而 Firefox 和 Safari 支持 screenX 和 screenY*\n\n4、opener\n返回对创建此窗口的窗口的引用。\n\n5、窗口关系\n\n* name\n    设置或返回窗口的名称。\n* parent\n    返回父窗口。\n* top\n    返回顶层的先辈窗口。\n* closed\n    返回一个窗口是否关闭。\n\n### <a name=\"diclku\"></a>事件\n\n另开一篇文章详述javascript的事件，关于window的事件不再重复赘述。\n"
  },
  {
    "title": "HCI之前端小任务 [HCI趣玩-2016年预热]",
    "description": "date: 2015-10-25tags: [hcife, linux, hci] 前端&amp;UI任务形式：2-3人一组，自由组合截止期限：2016年2月28日提交方式：在github上管理项目，在HCIFE的hcife-task处将项目地址提交到issue[图片] [图片] [图片]js插件静态资源如js,css,图片等资源的js打包加载器可参考Tiny-Loader.js,headjs打包可参考webpack纯js书写，不允许使用任何库ui图标设计一套ui图标可参考GLYPHICONS,Font...",
    "created_at": "2018-06-29T14:32:37.000Z",
    "updated_at": "2018-09-15T08:19:37.000Z",
    "published_at": "2018-09-15T08:19:37.000Z",
    "format": "asl",
    "slug": "ouhcn3",
    "last_editor": {
      "id": 103147,
      "type": "User",
      "login": "yinzhi",
      "name": "尹挚",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "followers_count": 9,
      "following_count": 5,
      "created_at": "2018-04-23T00:50:24.000Z",
      "updated_at": "2018-11-20T01:24:53.000Z",
      "_serializer": "v2.user"
    },
    "date": "2015-10-25 00:00:00 +0800",
    "tags": [
      "hcife",
      "linux",
      "hci"
    ],
    "body": "\n## <a name=\"t1fctq\"></a>前端&UI任务\n\n* 形式：2-3人一组，自由组合\n* 截止期限：2016年2月28日\n* 提交方式：在github上管理项目，在HCIFE的[hcife-task](https://github.com/hcife/hcife-task)处将项目地址提交到issue\n\n\n\n![image | left](https://cdn.yuque.com/yuque/0/2018/png/103147/1530282803431-b5780dbf-b24e-4d63-b6c0-1dd9c6b59ced.png \"\")\n\n\n\n![image | left](https://cdn.yuque.com/yuque/0/2018/png/103147/1530282822336-02f84bf5-0ff8-4cc7-a76b-8c970b23e0c3.png \"\")\n\n\n\n![image | left](https://cdn.yuque.com/yuque/0/2018/png/103147/1530282827085-fefe2904-0512-476c-aed4-10e9416f03b8.png \"\")\n\n\n### <a name=\"319xxu\"></a>js插件\n\n* 静态资源如js,css,图片等资源的js打包加载器\n* 可参考[Tiny-Loader.js](https://github.com/youzan/tiny-loader.js),[headjs](https://github.com/headjs/headjs)\n* 打包可参考[webpack](http://webpack.github.io)\n* 纯js书写，不允许使用任何库\n\n### <a name=\"3xhpmu\"></a>ui图标\n\n* 设计一套ui图标\n* 可参考[GLYPHICONS](http://glyphicons.com/),[Font-Awesome](https://github.com/FortAwesome/Font-Awesome),[IcoMoon](https://github.com/Keyamoon/IcoMoon-Free),[Ionicons](https://github.com/driftyco/ionicons),[Octicons!](https://github.com/github/octicons)\n* 实现基本即可，至少30个，不允许抄袭\n\n### <a name=\"kc3sqn\"></a>webgl建模\n\n* 构建一个简单的3D世界\n* 可参考[WebGLBook](https://github.com/tparisi/WebGLBook)\n* 这世界有点假。。。\n\n"
  },
  {
    "title": "Nginx虚拟主机管理系统 [HCI趣玩-2016年预热]",
    "description": "date: 2015-12-31tags: [linux, hci, nginx] 欢迎来访HCI第一次趣玩作业，本次作业主要是完成简易的ningx虚拟主机管理系统。所涉及的知识涵盖linux的基本管理命令、nginx/ftp服务器配置、简单的前端页面处理和后台逻辑。Nginx知多少Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like 协议下发行。由俄罗斯的程序设计师Igor Sysoev...",
    "created_at": "2018-06-29T14:31:48.000Z",
    "updated_at": "2018-09-15T08:21:01.000Z",
    "published_at": "2018-09-15T08:21:01.000Z",
    "format": "asl",
    "slug": "ifxd94",
    "last_editor": {
      "id": 103147,
      "type": "User",
      "login": "yinzhi",
      "name": "尹挚",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "followers_count": 9,
      "following_count": 5,
      "created_at": "2018-04-23T00:50:24.000Z",
      "updated_at": "2018-11-20T01:24:53.000Z",
      "_serializer": "v2.user"
    },
    "date": "2015-12-31 00:00:00 +0800",
    "tags": [
      "linux",
      "hci",
      "nginx"
    ],
    "body": "\n欢迎来访HCI第一次趣玩作业，本次作业主要是完成简易的ningx虚拟主机管理系统。所涉及的知识涵盖linux的基本管理命令、nginx/ftp服务器配置、简单的前端页面处理和后台逻辑。\n\n### <a name=\"iftvmh\"></a>Nginx知多少\n\nNginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like 协议下发行。由俄罗斯的程序设计师Igor Sysoev所开发，供俄国大型的入口网站及搜索引擎Rambler（俄文：Рамблер）使用。其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、新浪、网易、腾讯等。【摘抄自百度百科】\n\n<!-- more -->\n\n* 官方网站：[http://nginx.org](http://nginx.org)\n* 淘宝运维的nginx-book(*想深入了解的同学看这里*): [https://github.com/taobao/nginx-book](https://github.com/taobao/nginx-book)\n\n### <a name=\"yhetnf\"></a>前言\n\n* 体验传送门(新浪云)：[http://sinaapp.com/](http://sinaapp.com/)\n* 概要：日常情况下我们经常把应用部署到公开于网络的服务器上，而应用通过IP或域名访问，但于IP（端口）的数量限制，我们不得不剑走偏锋使用共享IP的方式。于是虚拟主机技术横空出世，可以从一台网络服务器上分配出磁盘空间供用户放置站点、应用组件给不同的虚拟主机，提供必要的站点功能、数据存放和传输功能，因此一个IP（套接字）可以直接运行多个多个网络应用。类似于新浪云、西部数码等虚拟主机提供商如雨后春笋般拔地而起。\n\n### <a name=\"cuzpga\"></a>设计目标\n\n* 一个可用的虚拟主机管理系统，可以添加/删除/修改/查看多个虚拟主机（只需支持静态文件服务器），同时生成一个账户（账号名+密码）对该主机进行管理。\n* 每个虚拟主机对应一个域名和项目文件路径\n* 每个虚拟主机所运行的项目文件路径（空间）由系统自动生成，选用ftp/svn/git其中一种代码部署方式控制\n\n### <a name=\"4vtcxf\"></a>举个栗子\n\n以下介绍的服务器为HCI内部服务器，运行着HCI的官方网站、竞考网微信公众号后台、weinre调试服务器等应用，所有应用使用不同的域名和同一个套接字（IP+端口）。下面我们来简单分析nginx的配置文件。\n\nnginx.conf局部\n\n```\n# nginx.conf局部\n# 添加虚拟主机配置文件目录\n\nhttp {\n\n        ##\n        # Basic Settings\n        ##\n\n        sendfile on;\n        tcp_nopush on;\n        types_hash_max_size 2048;\n        server_names_hash_bucket_size 64;\n        # server_tokens off;\n\n        # server_names_hash_bucket_size 64;\n        # server_name_in_redirect off;\n\n        include /etc/nginx/mime.types;\n        default_type application/octet-stream;\n\n        ##\n        # Logging Settings\n        ##\n\n        access_log /var/log/nginx/access.log;\n        error_log /var/log/nginx/error.log;\n\n        ##\n        # Gzip Settings\n        ##\n\n        gzip on;\n        gzip_disable \"msie6\";\n\n        # gzip_vary on;\n        # gzip_proxied any;\n        # gzip_comp_level 6;\n        # gzip_buffers 16 8k;\n        # gzip_http_version 1.1;\n\n        ##\n        # nginx-naxsi config\n        ##\n        # Uncomment it if you installed nginx-naxsi\n        ##\n\n        #include /etc/nginx/naxsi_core.rules;\n\n        ##\n        # nginx-passenger config\n        ##\n        # Uncomment it if you installed nginx-passenger\n        ##\n\n        #passenger_root /usr;\n        #passenger_ruby /usr/bin/ruby;\n\n        ##\n        # Virtual Host Configs\n        ##\n\n        include /etc/nginx/conf.d/*.conf;\n        include /etc/nginx/sites-enabled/*;\n        #===================================#\n        include /etc/nginx/vhosts/*;\t# 添加虚拟主机配置文件目录\n        #===================================#\n}\n```\n\n官网配置文件\n\n```\n# 官网配置（静态文件服务器+PHP）\n# /etc/nginx/sites-enabled/default\n\n#===============================\n#\n#       HCI Server\n#\n#================================\nupstream nodejs__upstream {\n        server 127.0.0.1:3000;\n        keepalive 64;\n}\nserver {\n        listen 80 default_server;\n        listen [::]:80 default_server ipv6only=on;\n        server_name localhost scauhci.org www.scauhci.org;\n\n        root /var/www/HCIWEB-SCAU/home;\n        index index.php index.html index.htm;\n\n        location / {\n                try_files $uri $uri/ /index.php$is_args$args;\n                client_max_body_size    10m;\n                # proxy_pass http://localhost:3000;\n                # First attempt to serve request as file, then\n                # as directory, then fall back to displaying a 404.\n                # Uncomment to enable naxsi on this location\n                # include /etc/nginx/naxsi.rules\n        }\n\n        location ^~ /jingkao {\n                proxy_pass http://nodejs__upstream;\n        }\n\n        location ~ \\.php$ {\n                fastcgi_pass 127.0.0.1:9000;\n                fastcgi_index index.php;\n                fastcgi_param SCRIPT_FILENAME /etc/nginx/sites-enabled/default$fastcgi_script_name;\n                include /etc/nginx/fastcgi_params;\n        }\n}\n```\n\n虚拟主机目录\n\n```\n# 虚拟主机目录\n106 Dec  6 06:17 jingkao.com.conf\n135 Dec 26 11:32 weinre.conf\n111 Dec 13 16:19 xsx.conf\n175 Jan 15 21:03 ypf.conf\n131 Dec 25 16:34 zsl.conf\n131 Dec 25 16:34 zsl.conf\n```\n\n虚拟主机实例：weinre服务器\n\n```\n# weinre服务器\nserver {\nlisten 80;\nserver_name weinre.scauhci.com;\nlocation / {\n\t\t# 反向代理到服务器B的8080端口\n        proxy_pass http://192.168.100.4:8080;\n}\n}\n```\n\n虚拟主机实例：用于本次作业的测试服务器\n\n```\n# 测试服务器\nserver {\nlisten 80;\nserver_name test1.scauhci.com;\nroot /var/www/test;\nindex index.html;\n}\n```\n\n应用列表(就不一一例举全部应用了)：\n\n* [HCI官网](http://www.scauhci.org)\n\n运行在`http://www.scauhci.com/`和`http://121.201.58.180:80`上，项目文件路径为/var/www/HCIWEB-SCAU/home，假设此文件夹只能由FTP账户（账号名: hci，密码：hci\\_pass）使用ftp对`ftp://www.scauhci.com/hci_home/`进行读写。\n\n* [用于本次作业的测试服务器](http://test1.scauhci.com)\n\n运行在`http://weinre.scauhci.com/`和`http://121.201.58.180:80`上，项目文件路径为/var/www/test，假设此文件夹只能由FTP账户（账号名: hci1，密码：hci1\\_pass）使用ftp对`ftp://www.scauhci.com/test/`进行读写。\n\n### <a name=\"nmq5wr\"></a>设计思路和流程\n\n1. 熟悉Linux环境和Nginx的配置(需部分成员了解)\n2. 设计WEB管理系统，需简单的数据库保存虚拟主机的信息（域名、文件路径等）以及管理员信息（只设计一名管理员）\n3. 模拟管理虚拟主机，同时对vhosts文件进行文本分析，了解规则后可以进行虚拟主机的实际管理\n4. 如有余力可继续实现服务器性能参数的可视化（CPU占用率/内存使用情况/硬盘容量等）\n    \n\n\n\n![image.png | left | 677x312](https://cdn.yuque.com/yuque/0/2018/png/103147/1530282751584-bab5ba04-1af0-484d-bd72-f0d54ae130d7.png \"\")\n\n\n### <a name=\"iccxea\"></a>写几个可能遇到的问题\n\n1. 文件权限的问题：每个应用对应的路径（文件夹）是相对独立的，且只能由对应的用户进行读写\n2. 考虑到DNS服务器的复杂性问题，本次作业无须自己搭建DNS服务器，统一分配10个二级域名用于实验\n3. nginx的平滑重载:`kill -HUP cat '/usr/local/nginx/logs/nginx.pid'`或者`nginx -s reload`\n4. ftp/svn/git 服务器的配置不再赘述，各位还请发挥自我学习能力搜集资料。\n\n### <a name=\"l7mrdw\"></a>技能列表\n\n* [Linux入门知识](https://www.shiyanlou.com/courses/1)\n* ssh/ftp(或者svn/git)/nginx等服务器搭建和配置\n* nginx进阶配置\n* 后端：简单的 数据库处理、文件处理、业务逻辑设计\n* 前端：一个管理后台的页面/如有余力则设计可视化的性能监控图形界面\n* 协作工具：git[(coding)](https://coding.net/git#)/[teambition](http://teambition.com/)\n* 规范化的开发流程：需求文档->原型设计->（设计图）->开发->测试->上线\n\n### <a name=\"nkddns\"></a>成果：\n\n* 可展示和使用的虚拟主机管理系统\n* 完整的源代码和文档\n\n### <a name=\"k5k5hn\"></a>后话\n\n本作业难度适中，但涉及的分支非常丰富，适于团队合作，期望各位能涉及多方面的技术，另外需要对项目有大局的思考方式。建议3-5人一组，可挑选一名13级的师兄/师姐作为指导。有任何问题可直接在`HCI@上有老下有小群`讨论。也可以在本文后面的评论框直接评论。\n\n（懒懒的很久不写博客，各路大侠见谅）\n"
  },
  {
    "title": "爬虫的简单实现 [HCI趣玩-2016年预热]",
    "description": "date: 2015-12-31tags: [爬虫, hci]欢迎来访HCI第一次趣玩作业，本次作业主要是完成爬虫的简单设计以及掌握团队协作工具的应用。爬虫知多少概要：网络爬虫（又被称为网页蜘蛛，网络机器人，在FOAF社区中间，更经常的称为网页追逐者），是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。另外一些不常使用的名字还有蚂蚁、自动索引、模拟程序或者蠕虫。&lt;!-- more --&gt...",
    "created_at": "2018-06-29T14:31:11.000Z",
    "updated_at": "2018-09-15T09:28:14.000Z",
    "published_at": "2018-09-15T09:28:14.000Z",
    "format": "asl",
    "slug": "zquy3r",
    "last_editor": {
      "id": 103147,
      "type": "User",
      "login": "yinzhi",
      "name": "尹挚",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "followers_count": 9,
      "following_count": 5,
      "created_at": "2018-04-23T00:50:24.000Z",
      "updated_at": "2018-11-20T01:24:53.000Z",
      "_serializer": "v2.user"
    },
    "date": "2015-12-31 00:00:00 +0800",
    "tags": [
      "爬虫",
      "hci"
    ],
    "body": "\n欢迎来访HCI第一次趣玩作业，本次作业主要是完成爬虫的简单设计以及掌握团队协作工具的应用。\n\n### <a name=\"zplldu\"></a>爬虫知多少\n\n概要：网络爬虫（又被称为网页蜘蛛，网络机器人，在FOAF社区中间，更经常的称为网页追逐者），是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。另外一些不常使用的名字还有蚂蚁、自动索引、模拟程序或者蠕虫。\n\n<!-- more -->\n\n### <a name=\"e8qska\"></a>项目概要\n\n本次项目主要目的为简单的网页抓取和数据处理。本次需要抓取的网站为豆瓣读书。进行分类后存储到本地文件或数据库。\n\n### <a name=\"0t9vie\"></a>思路教程\n\n* 体验和发现url规则(如学院OJ系统报名列表[http://acm.scau.edu.cn:8000/uoj/register/displayActivity.html?id=29&page=1\"](http://acm.scau.edu.cn:8000/uoj/register/displayActivity.html?id=29&page=1%22)，这里的page就是页码)\n* 获取网页文件\n* 分析页面元素，抓取有效数据\n\n心有余力的同学可以尝试迭代分析页面元素（链接）抓取整站页面。（需要考虑链接的重复性和同属于一站）\n\n### <a name=\"t5ckpu\"></a>部分教程（思路）\n\n时间有限，对此也不再赘述，参考如下文章:\n\n* Python教程: [https://www.thenewboston.com/forum/topic.php?id=1610](https://www.thenewboston.com/forum/topic.php?id=1610) （参考技术：request和bs4）\n* powershell部分代码\n\n```\n# 抓取页面\n$web = New-Object System.Net.WebClient\n$web.Encoding = [System.Text.Encoding]::UTF8\n$str = $web.DownloadString(\"http://localhost\")\n$str\n\n# 分析HTML\nfunction Get-HtmlElement ($Id,$Name,$Class,$Tag)\n{\n    if($Id)\n    {\n        return $ie.Document.getElementById($id)\n    }\n    elseif($Name)\n    {\n        return $ie.Document.getElementsByName($Name)\n    }\n    elseif($Class)\n    {\n        $ie.Document.all |　where {$_.className -contains $Class}\n    }\n    elseif($Tag)\n    {\n        $ie.Document.getElementsByTagName($Tag)\n    }\n}\n```\n\n* 其他语言一律欢迎\n\n### <a name=\"tudgkb\"></a>成果\n\n* 有效的可视化数据（网页或者其他形式的报表等）\n* 源代码和说明文档\n\n*提交方式：在git.oschina.net上管理项目，在scauhci的hci-spider处将项目地址提交到issue*\n\n### <a name=\"u3e6wl\"></a>后话\n\n本作业为小组作业或个人作业，建议人数不超过2人，可以选择使用自己最熟悉的语言编写。同样需要邀请一位13级师兄/师姐作为指导。强烈推荐大家学习多样化的语言！有任何疑问，可直接在`HCI@上有老下有小群`讨论。也可以在本文后面的评论框直接评论。\n"
  },
  {
    "title": "HCI第一次分享例会[命令行]",
    "description": "date: 2015-10-25tags: [cmd, linux, hci] 欢迎来访HCI第一次例会分享，今天小编（HCI-鹏飞）需要分享的是linux和windows命令行的基本命令以及技巧。关于linux知多少概要：开源、多用户多任务、支持多线程多CPU的操作系统（基于POSIX和UNIX），以网络为核心而设计，可以运行UNIX工具、应用程序和网络协议。Linux内核版本已经升级到4.3。(内核源代码Git仓库：https://git.kernel.org/)。 特性：强大的控制台和Linux...",
    "created_at": "2018-06-29T14:29:11.000Z",
    "updated_at": "2018-09-15T08:19:53.000Z",
    "published_at": "2018-09-15T08:19:53.000Z",
    "format": "asl",
    "slug": "chomfq",
    "last_editor": {
      "id": 103147,
      "type": "User",
      "login": "yinzhi",
      "name": "尹挚",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "followers_count": 9,
      "following_count": 5,
      "created_at": "2018-04-23T00:50:24.000Z",
      "updated_at": "2018-11-20T01:24:53.000Z",
      "_serializer": "v2.user"
    },
    "date": "2015-10-25 00:00:00 +0800",
    "tags": [
      "cmd",
      "linux",
      "hci"
    ],
    "body": "\n欢迎来访HCI第一次例会分享，今天小编（HCI-鹏飞）需要分享的是linux和windows命令行的基本命令以及技巧。\n\n### <a name=\"bovtlm\"></a>关于linux知多少\n\n概要：开源、多用户多任务、支持多线程多CPU的操作系统（基于POSIX和UNIX），以网络为核心而设计，可以运行UNIX工具、应用程序和网络协议。Linux内核版本已经升级到4.3。(内核源代码Git仓库：[https://git.kernel.org/](https://git.kernel.org/))。\n特性：强大的控制台和Linux终端环境以及桌面环境如GNOME, KDE, XFCE和 LXDE，稳定性高安全性较高。\n\n<!-- more -->\n\n应用场景：\n\n\n\n\n![image.png | left | 442x693](https://cdn.yuque.com/yuque/0/2018/png/103147/1530282614096-ab87ccb8-d840-4f46-8e0b-d854f6f28999.png \"\")\n\n\n### <a name=\"np1gov\"></a>言归正传，下面开始进入正题。开始讲解linux(局部windows的命令行)\n\n* 用户管理\n\n```Bash\n查看当前登录的用户名：who am i \\ who mom likes\n添加用户：adduser hci\n修改密码：passwd\n用户组查询：groups [root](cat /etc/group)\n添加到组：usermod -G sudo hci\n删除用户：deluser hci --remove-home\n```\n\n* 文件管理\n\n> 文件权限：\n\n```Bash\n查看文件权限：ls -l\n```\n\n\n\n![image.png | left | 747x141](https://cdn.yuque.com/yuque/0/2018/png/103147/1530282638549-5e6ff30a-676f-4162-a8af-fb1b07a735cc.png \"\")\n\n\n\n![image.png | left | 528x363](https://cdn.yuque.com/yuque/0/2018/png/103147/1530282646577-acd64bd4-6eaa-41dc-a9e4-5c4627293458.png \"\")\n\n\n```Bash\n更改所有者：chown\n更改文件权限：chmod (直接赋值和加减权限)\nchmod go-rw hci\n# 'g''o'还有'u'，分别表示group，others，user，'+'，'-' 就分别表示增加和去掉相应的权限\n\n```\n\n\n\n![image.png | left | 747x245](https://cdn.yuque.com/yuque/0/2018/png/103147/1530282661213-c3bd0152-16ce-4546-9a6c-4a0b1cb83833.png \"\")\n\n\n[ps: 三组权限：拥有者、所属用户组、其他用户]\n> 操作文件：\n\n```Bash\n切换目录：cd\\pushd\n新建文件：touch\n新建目录：mkdir\n查看目录：ls\n删除文件、目录：rm\\rm -rf\n复制文件：cp\n移动文件：mv\n重命名：rename\n查看文件：cat\\tac\\ln\n查看文件首尾：head\\tail\n逐行显示：more\\less\n查看文件类型：file\n```\n\n* 文本处理\n    主要工具vi\\vim：屏幕编辑和行编辑模式\n* 环境变量\n    运行环境的变量。\n\n```Bash\n定义变量：declare\n删除变量：unset\n立即生效：source .bashrc\n用户Bash环境变量文件：~/.bashrc(根据终端环境如zsh的.zshrc)\n系统环境变量：/etc/profile(/etc/bashrc)\n```\n\n* 其他技巧\n\n```Bash\n回显筛选：grep\n查找文件：where(qs)\\locate(qm)\\whic(sr)\\find\n查看进程：ps\n任务管理器：top\n重启：reboot\n关机：poweroff\\shutdown\\init\n创建归档：tar(-c -x)\n下载文件：wget\n挂载文件系统：mount\\unmount\n帮助文档：man\\info\n```\n\n"
  },
  {
    "title": "Docker大行其道—初识",
    "description": "tags: [linux, docker]date: 2016-05-29随着分布式、云计算、大数据的火热爆发，大量的云计算集群出现，光凭计算机硬件配置的已经无法再次一较高下，虚拟化成为其中最核心的技术。虚拟化既可以通过硬件模拟，也可以通过操作系统层面去实现，近年来热火朝天的容器轻量级虚拟化，保留了操作系统本身的机制和特性，而Docker在此脱颖而出。Docker的前世今生Docker是基于Go语言实现的云开源项目，目前归于Apache基金会并遵循Apache 2.0协议。诞生于201...",
    "created_at": "2018-06-29T14:27:34.000Z",
    "updated_at": "2018-09-15T12:44:44.000Z",
    "published_at": "2018-09-15T12:44:44.000Z",
    "format": "asl",
    "slug": "zphz8h",
    "last_editor": {
      "id": 103147,
      "type": "User",
      "login": "yinzhi",
      "name": "尹挚",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "followers_count": 9,
      "following_count": 5,
      "created_at": "2018-04-23T00:50:24.000Z",
      "updated_at": "2018-11-20T01:24:53.000Z",
      "_serializer": "v2.user"
    },
    "tags": [
      "linux",
      "docker"
    ],
    "date": "2016-05-29 00:00:00 +0800",
    "body": "\n随着分布式、云计算、大数据的火热爆发，大量的云计算集群出现，光凭计算机硬件配置的已经无法再次一较高下，虚拟化成为其中最核心的技术。虚拟化既可以通过硬件模拟，也可以通过操作系统层面去实现，近年来热火朝天的容器轻量级虚拟化，保留了操作系统本身的机制和特性，而Docker在此脱颖而出。\n\n### <a name=\"pkigdt\"></a>Docker的前世今生\n\nDocker是基于Go语言实现的云开源项目，目前归于Apache基金会并遵循Apache 2.0协议。诞生于2013年初，前身公司为dotCloud，docker开源后得到受到社会广泛的关注，docker的生态圈体系也逐渐成熟，这家公司也改名为Docker Inc，专注于Docker相关技术和产品开发。\n\n<!-- more -->\n\nDocker最大的目标是：“Build, Ship and Run Any App, Anywhere！”。你只需要通过对应用组件的一次的封装，就能在任意地点构建和运行你的应用。无论是一个完整的应用，或者是某些微服务，甚至到一个完整的操作系统都能成为docker的应用组件。Docker提供一个高效、敏捷和轻量的容器方案，能动态适应各种规模的系统部署需求。\n\nDocker整个生命周期包含三部分：镜像（Image），容器（Container），仓库（Repository）。镜像和容器的关系就像程序和进程，镜像是容器运行的一大前提，而容器则是镜像的一个运行实例。仓库则是镜像的管理中心，默认的镜像仓库为Docker Hub。\n\n\n\n![image.png | left | 747x477](https://cdn.yuque.com/yuque/0/2018/png/103147/1530282528817-dfd72221-6fc4-4fb2-9f5a-da659e85f848.png \"\")\n\n\nDocker运行容器前需要检查本地是否存在对应的镜像，如果不存在，会尝试从默认的镜像仓库下载。镜像实例化之后运行着一个完整的容器，容器除了镜像本身的内容外，还提供额外的可写文件层以及相对独立的运行环境（可能是一些应用或者服务，也可能是完整的操作系统）。\n\n作为一个C/S模型的项目，Docker通过Docker Host进行镜像、容器、守护进程、分区等的管理，同时在Docker Client进行镜像的拉取，容器的构建等操作，通常情况下Host和Client可能会在同一台机器上。\n\nDocker开源代码地址：[https://github.com/docker/docker](https://github.com/docker/docker)\n\n### <a name=\"s3oqts\"></a>Docker得天独厚的优势\n\n### <a name=\"2t21gp\"></a>新的部署方式\n\n假如当前有这么一个场景：“由于业务增长，公司的一个网站项目需要迁移到新的服务器”。按照传统方案，我们很可能需要作一些重复性的工作。首先需要在新的服务器上安装对应的运行环境以及对应的依赖，如LAMP（Linux+Apache+Mysql+PHP），创建对应的用户或组并进行文件权限的管理，耗费大量的精力后，还需要对该环境进行测试，最后才能部署上线。试想一下，如果这样的需求多少十几倍，这些工作需要重复的执行。\n\n也许你会说可以通过虚拟化的技术将整个环境打包成镜像再进行部署，加入新的服务器本身也是一台虚拟化的机器，再加上一层xen（或者其他虚拟机）去部署显然显得多余了。\n\n而Docker提供一种极为简便的操作方式，通过容器来进行应用打包，我们可以通过封装成镜像或是编写Dockerfile等方式来进行打包，这意味着在新的服务器上只需要启动所需要的容器即可。一来节省了大量的时间投入，而来降低了部署过程出现问题带来的隐患。\n\n### <a name=\"94q1bk\"></a>运维策略的革新\n\n1. 极速交付和部署\n\n使用docker，开发人员可以使用镜像快速构建一套标准的开发环境。之后的测试和上线环节完全可以复用这套镜像将应用部署到测试环境或生产环境等任意地方。Docker可以快速创建、删除容器，并保留了每一个步骤的配置和操作过程，降低开发、测试、部署的时间的同时让环境部署更容易被理解。通过简单的配置文件修改，就能轻松完成一次运行环境的迭代，所有操作都可以以增量的形式进行分发和更新，从而实现自动化和高效的容器管理。\n\n1. 性能损耗低\n\n事实上docker是内核级别的虚拟化，不需要额外的虚拟化管理程序，因此开启docker对性能的损耗几乎忽略不计。\n\n1. 轻便易迁移拓展\n\nDocker几乎支持任意平台运行，无论是物理机还是虚拟化的主机，甚至个人电脑都能兼容运行docker，这种兼容性可以让应用更方便切换运行平台。\n\n1. 规范化的标准\n\nDocker背后的标准化容器执行引擎 - runC。runC是由docker贡献后续完善的一个开放的工业化标准，其主要内容：\n\n* __操作标准化__：容器的标准化操作包括使用标准容器感觉创建、启动、停止容器，使用标准文件系统工具复制和创建容器快照，使用标准化网络工具进行下载和上传。\n* __内容无关__：内容无关指不管针对的具体容器内容是什么，容器标准操作执行后都能产生同样的效果。如容器可以用同样的方式上传、启动，不管是php应用还是mysql数据库服务。\n* __基础设施无关__：无论是个人的笔记本电脑还是AWS S3，亦或是Openstack，或者其他基础设施，都应该对支持容器的各项操作。\n* __为自动化量身定制__：制定容器统一标准，是的操作内容无关化、平台无关化的根本目的之一，就是为了可以使容器操作全平台自动化。\n* __工业级交付__：制定容器标准一大目标，就是使软件分发可以达到工业级交付成为现实。\n\n1. 集群管理\n\nKubernetes是Google开源的Docker容器集群管理系统，为容器化的应用提供资源调度、部署运行、服务发现、扩容缩容等整一套功能，本质上可看作是基于容器技术的mini-PaaS平台。\n\n\n\n![image.png | left | 747x545](https://cdn.yuque.com/yuque/0/2018/png/103147/1530282540268-e4b8ef20-e07f-40a7-9dc4-9df606ee60f9.png \"\")\n\n\n关于Docker和虚拟机的比较，请参考：[http://www.linuxprobe.com/docker-and-vm.html](http://www.linuxprobe.com/docker-and-vm.html)\n\n关于Docker的标准，请参考：[http://www.open-open.com/lib/view/open1444481959869.html](http://www.open-open.com/lib/view/open1444481959869.html)\n\n### <a name=\"70g4ri\"></a>文章小节\n\n全文主要对docker进行概念性的介绍，想必读到这里，docker再也不会是一个陌生的技术。无论是在针对应用的自动化运维还是PAAS的管理策略，docker都能提供一套优秀的解决方案，docker在领域内倍受青睐，让运维的工作有了前所未有的优质体验。如果你也被docker的魅力深深折服的话，欢迎加入到docker的学习行列一同探索。\n"
  },
  {
    "title": "CSS优先级",
    "description": "tags: [css]date: 2015-04-18优先级排序[1位重要标志位] &gt; [4位特殊性标志] &gt; 声明先后顺序!important &gt; [ id &gt; class &gt; tag ] ps：使用!important可以改变优先级别为最高，其次是style对象，然后是id &gt; class &gt; tag ，另外，另外在同级样式按照申明的顺序后出现的样式具有高优先级。&lt;!-- more --&gt;4位特殊性标志 [0.0.0....",
    "created_at": "2018-06-29T14:26:43.000Z",
    "updated_at": "2018-09-15T08:10:47.000Z",
    "published_at": "2018-09-15T08:10:47.000Z",
    "format": "asl",
    "slug": "qgvhqy",
    "last_editor": {
      "id": 103147,
      "type": "User",
      "login": "yinzhi",
      "name": "尹挚",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "followers_count": 9,
      "following_count": 5,
      "created_at": "2018-04-23T00:50:24.000Z",
      "updated_at": "2018-11-20T01:24:53.000Z",
      "_serializer": "v2.user"
    },
    "tags": [
      "css"
    ],
    "date": "2015-04-18 00:00:00 +0800",
    "body": "\n## <a name=\"t0ngis\"></a>优先级排序\n\n* [1位重要标志位] > [4位特殊性标志] > 声明先后顺序\n\n```Bash\n!important > [ id > class > tag ]\n```\n\nps：使用!important可以改变优先级别为最高，其次是style对象，然后是id > class > tag ，另外，另外在同级样式按照申明的顺序后出现的样式具有高优先级。\n\n<!-- more -->\n\n* 4位特殊性标志 [0.0.0.0]：从左至右，每次给某一个位置+1，前一段对后一段具有无可辩驳的压倒性优势。无论后一位数值有多大永远无法超过前一位的1。\n    * 内联样式 [1.0.0.0]\n        A：\n        B：还有就是JS控制的内联样式style对象，document.getElementById(\"demo\").style.color=\"red\";\n        两者属于同一级别，不过一般情况是JS控制的内联样式优先级高，这与先后顺序申明有关系与本质无关，因为往往DOM操作是在DOM树加载完毕之后。\n    * ID选择器 [0.1.0.0]\n    * 类，属性，伪类 选择器 [0.0.1.0]\n    * 元素标签，伪元素 选择器 [0.0.0.1]\n* LVHA伪类,样式按LVHA优先级顺序从右至左覆盖，不同的顺序会产生不同的效果。\n    a:link - 默认链接样式\n    a:visited - 已访问链接样式\n    a:hover - 鼠标悬停样式\n    a:active - 鼠标点击样式\n\n"
  },
  {
    "title": "批处理机房文件批量传输",
    "description": "tags: [bat]date: 2015-10-17题记计算机维护队将于次日在机房进行队员第一次培训会，培训会上的队员实操过程则需要使用到win7和PE镜像，工作人员（委员）不得不提前拷贝好镜像到每一台机子。于是便有了机房内通过网络批量传输文件的想法，实现之后可以大大减轻工作量，传输速度上瓶颈为100Mbps（机房网络配置），与普通USB3.0的U盘传输速率相比确实低了一大截，在传输速率上似乎不占优势，因此我们将多台主机作为源点传输数据，并行传输数据，大大提升了时间效率。[图片]&lt;!-- more...",
    "created_at": "2018-06-29T14:20:43.000Z",
    "updated_at": "2018-09-15T09:27:30.000Z",
    "published_at": "2018-09-15T09:27:30.000Z",
    "format": "asl",
    "slug": "sk5uz1",
    "last_editor": {
      "id": 103147,
      "type": "User",
      "login": "yinzhi",
      "name": "尹挚",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "followers_count": 9,
      "following_count": 5,
      "created_at": "2018-04-23T00:50:24.000Z",
      "updated_at": "2018-11-20T01:24:53.000Z",
      "_serializer": "v2.user"
    },
    "tags": [
      "bat"
    ],
    "date": "2015-10-17 00:00:00 +0800",
    "body": "\n## <a name=\"89ucqc\"></a>题记\n\n计算机维护队将于次日在机房进行队员第一次培训会，培训会上的队员实操过程则需要使用到win7和PE镜像，工作人员（委员）不得不提前拷贝好镜像到每一台机子。于是便有了机房内通过网络批量传输文件的想法，实现之后可以大大减轻工作量，传输速度上瓶颈为100Mbps（机房网络配置），与普通USB3.0的U盘传输速率相比确实低了一大截，在传输速率上似乎不占优势，因此我们将多台主机作为源点传输数据，并行传输数据，大大提升了时间效率。\n\n<div data-type=\"alignment\" data-value=\"center\" style=\"text-align:center\">\n  <div data-type=\"p\">\n    <div id=\"sdxuoz\" data-type=\"image\" data-display=\"block\" data-align=\"center\" data-src=\"https://cdn.yuque.com/yuque/0/2018/png/103147/1530282323573-b3ec65c0-c8fc-4dec-a92f-4da95966b6da.png\" data-width=\"391\">\n      <img src=\"https://cdn.yuque.com/yuque/0/2018/png/103147/1530282323573-b3ec65c0-c8fc-4dec-a92f-4da95966b6da.png\" width=\"391\" />\n    </div>\n  </div>\n  <div data-type=\"p\"></div>\n</div>\n\n<!-- more -->\n\n### <a name=\"hxqrtl\"></a>机遇阶段\n\n很凑巧，在同类型的机房中上实验课的时候一不小心执行了以下powershell指令：\n\n```\nGet-WmiObject -Class Win32_Share -Computername [computername]\n# [computername] 代表主机名\n```\n\n意外的收获，默认共享居然没有被关闭，切安全策略~[偷笑]!\n\n```\nName     Path                          Description\n----     ----                          -----------\nADMIN$   C:\\Windows                    远程管理\nC$       C:\\                           默认共享\nD$       D:\\                           默认共享\nIPC$                                   远程 IPC\n```\n\n然而不出所料，我尝试通过net use空连接到旁边的机子时，被无情的拒之门外。要知道机房的电脑都是自带默认密码的。\n\n```\nnet use z: \\\\[computername]\\D$\n\n为 '[computername]' 输入用户名:\n发生系统错误 1223。\n操作已被用户取消。\n```\n\n好吧，确实是个棘手的问题，因为不可能提前手动更改用户密码，因为机房的电脑自带还原程序（且不可恶意破坏），因此不得不废弃这个方案。于是编者剑走偏锋，掏出了一代神器[mimikatz\\_trunk](http://blog.gentilkiwi.com/presentations)，利用这个神器(原理是通过彩虹表破解NTLM加密口令)可以轻易获取windows系统账户的明文密码。\n\n#### <a name=\"uxiodh\"></a>下载链接\n\n* [Binaires](https://github.com/gentilkiwi/mimikatz/releases/latest)\n\n* [Sources](https://github.com/gentilkiwi/mimikatz)\n\n使用说明详参[README.md](https://github.com/gentilkiwi/mimikatz/blob/master/README.md)，下载后或编译后程序目录如下：\n\n\n\n![image.png | left | 657x169](https://cdn.yuque.com/yuque/0/2018/png/103147/1530282348556-f8855387-6730-4b14-ae05-6d72a8fecffa.png \"\")\n\n\n我们接着运行如下命令即可获得账户明文密码：\n\n```\n# 提升权限\nmimikatz # privilege::debug\nPrivilege '20' OK\n\n# 获取密码\nmimikatz # sekurlsa::logonpasswords\n\n```\n\n获取密码后部分结果如下：\n\n```\n# *是编者自己打上的马赛克，命令执行后输出的全为明文，下同\nAuthentication Id : 0 ; 298372 (00000000:00048d84)\nSession           : Interactive from 1\nUser Name         : ******\nDomain            : ****\nLogon Server      : (null)\nLogon Time        : 2015-10-16 20:54:11\nSID               : S-1-5-21-*******-********-*********-1004\n        msv :\n         [00000003] Primary\n         * Username : ******@outlook.com\n         * Domain   : MicrosoftAccount\n         * Flags    : I00/N01/L00/S01\n         * NTLM     : 198469ad0**********ed7ddfadd94\n         * SHA1     : 1018ac5781ab260******8b9d57fae11d3313a86\n        tspkg :\n         * Username : ******@outlook.com\n         * Domain   : MicrosoftAccount\n         * Password : ********\n        wdigest :\n         * Username : ******@outlook.com\n         * Domain   : MicrosoftAccount\n         * Password : ******\n        kerberos :\n         * Username : ******@outlook.com\n         * Domain   : MicrosoftAccount\n         * Password : (null)\n        ssp :\n        credman :\n         [00000000]\n         * Username : (null)\n         * Domain   : MicrosoftOffice16_Data:SSPI:lxstart@outlook.com\n         * Password : ******\n\n```\n\n### <a name=\"k6o6ss\"></a>程序设计\n\n既然获取到了一台机子的明文密码（账户名默认为Administrator），由于机房采用统一镜像进行安装，因此默认账户信息完全一致，那么，就可以跳到批量传输的阶段了。那么我们来做一个详尽的规划：[篇幅有限，下面只提供关键代码]\n\n#### <a name=\"d8iolx\"></a>获取局域网内的主机名列表\n\n原理：通过net view获取局域网主机列表后进行字符串过滤筛选，得到最终的主机名列表并写入hosts.ini文件。\n\n```\n(for /f \"eol=。 skip=3 tokens=1 delims=, \" %%i in ('net view') do (\n\tfor /f \"tokens=1 delims=\\ \" %%a in ('echo %%i ^| findstr ^\\') do (\n\t\techo %%a\n\t)\n)) >> hosts.ini\n```\n\n#### <a name=\"tnyvtu\"></a>建立net use连接\n\n```\n# 将网络路径\\\\[hostname]\\d$映射到z:\\\nnet use z: \\\\[hostname]\\d$ \"******\" /user:\"administrator\" /persistent:yes\n```\n\n在这之前需要先释放z:原本可能存在net use连接：\n\n```\nnet use z: /delete\n```\n\n我们就可以直接通过访问z:来访问到目标机器的D盘根目录并进行文件操作了。\n\n#### <a name=\"xotpxv\"></a>复制文件\n\n推荐使用xcopy命令，参数较简单易懂。\n\n```\n# 假设D:\\已有win7.iso和PE.iso\nxcopy D:\\win7.iso Z:\\\nxcopy D:\\PE.iso Z:\\\n```\n\n#### <a name=\"odxkpc\"></a>批量复制\n\n由于我们已经获取到主机名列表，则我们可以串行批量复制文件。\n\n```\nfor /f  %%a in (hosts.ini) do (\n\techo 正在处理%%a\n\tcall :copyer %%a\n\t:: 删除映射，释放连接\n\tnet use z: /delete /y\n)\n\n# 定义函数\n:copyer\nnet use z: \\\\%~1\\d$ \"******\" /user:\"administrator\" /persistent:yes\nxcopy D:\\win7.iso Z:\\\nxcopy D:\\PE.iso Z:\\\n```\n\n#### <a name=\"850vsl\"></a>多主机并行处理\n\n将程序放置到多台主机下运行，划分主机名列表片段到不同的主机，则可同时执行不同的文件批量复制的任务。\n\n#### <a name=\"zdiwbh\"></a>最佳方案\n\n这里涉及一种类似于细胞分裂的算法技术，在上面原有的基础上添加更能提高效率的解决方案。假设每人负责部署一台主机（用于批量复制文件），复制完46台机子需要(46-6)/6=7轮，开始说表述的每台机子带宽有限（下面的流程图则以一台源主机为例解释），因此传输速度也难以提升。\n\n更合理的解决方案就是利用所有空闲切有镜像的主机的网络带宽，思路图对比大致如下：\n\n* 传统\n    \n\n\n\n![image.png | left | 686x459](https://cdn.yuque.com/yuque/0/2018/png/103147/1530282360282-26242597-1bcc-4ccf-a856-19fbd7ba6d09.png \"\")\n\n\n* 并行化\n\n\n\n![image.png | left | 692x439](https://cdn.yuque.com/yuque/0/2018/png/103147/1530282373553-b57fcc30-f2fc-4d16-b7eb-20431a7cebad.png \"\")\n\n\n关键要解决的问题是需要给下一台机器发送指令，分配给每台主机最优的复制队列：通过ipc\\$获取远程at和time权限\n\n```\n# 建立ipc$连接\nnet use \\\\[hostname]\\ipc$ \"password\" /user:\"username\"\n\n# 获取主机时间，假设为19:00\nnet time \\\\[hostname]\n\n# at 设置命令，假设transformListFile.bat包含了计算下一台机子需要复制到的目标队列的算法\nat \\\\[hostname] 19:01 transformListFile.bat\n\n```\n\n"
  },
  {
    "title": "批处理模拟守护进程",
    "description": "tags: [bat]date: 2015-01-23原理后台监听任务管理器列表中是否存在被守护的进程，核心代码如下：::守护chrome.exe进程 tasklist | findstr &quot;chrome.exe&quot; || start &quot;%ProgramFiles%\\Google\\Chrome\\Applicationchrome\\chrome.exe&quot; 主要知识点主要运用到管道符号&quot;|&quot;，配合findstr寻找并判断系统是否运行着&quot...",
    "created_at": "2018-06-29T14:19:48.000Z",
    "updated_at": "2018-09-15T08:14:09.000Z",
    "published_at": "2018-09-15T08:14:09.000Z",
    "format": "asl",
    "slug": "uozvfw",
    "last_editor": {
      "id": 103147,
      "type": "User",
      "login": "yinzhi",
      "name": "尹挚",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "followers_count": 9,
      "following_count": 5,
      "created_at": "2018-04-23T00:50:24.000Z",
      "updated_at": "2018-11-20T01:24:53.000Z",
      "_serializer": "v2.user"
    },
    "tags": [
      "bat"
    ],
    "date": "2015-01-23 00:00:00 +0800",
    "body": "\n### <a name=\"bnuhky\"></a>原理\n后台监听任务管理器列表中是否存在被守护的进程，*核心代码如下：*\n\n```\n::守护chrome.exe进程\ntasklist | findstr \"chrome.exe\" || start \"%ProgramFiles%\\Google\\Chrome\\Applicationchrome\\chrome.exe\"\n```\n\n### <a name=\"zwh7oo\"></a>主要知识点\n\n* 主要运用到管道符号\"|\"，配合findstr寻找并判断系统是否运行着\"chrome.exe\"，\"||\"连接符表示\"finstr\"未找到合适的进程，将执行后面的启动\"chrome.exe\"语句。\n\n<!-- more -->\n\n## <a name=\"i601vn\"></a>源码\n\n下面是一则源码，用于批量打开网页，并且在浏览器关闭后循环这个过程。【可拓展用途】\n\n```Bash\n@echo off\ntitle QAQ\nsetlocal enabledelayedexpansion\npushd %~dp0\n:start\nset /a index=0\nfor /f %%a in (config.ini) do (\n\tping %%a -n 1 > nul && (\n\t\tstart \"%ProgramFiles%\\Google\\Chrome\\Applicationchrome\\chrome.exe\" http://%%a\n\t\techo \t   !date! !time!: sent request to %%a\n\t\techo !date! !time!: sent request to %%a >> log.txt\n\t\tset /a index+=1\n\t\tping 127.1 -n 1 > nul\n\t)\n)\necho= >> log.txt\n\n:wait\ntasklist | findstr \"chrome.exe\" > nul || goto start\nping 127.1 -n 5 > nul\ngoto wait\n```\n\n"
  },
  {
    "title": "批处理后台运行",
    "description": "tags: [bat]date: 2015-01-28通过cmd的启动参数进行窗口隐藏cmd /c test #后台调用test并关闭当前进程 cmd /k test #后台调用test但不关闭当前进程 通过vbs直接启动cmd /c 和 cmd /k隐藏控制台窗口时，依然会出现一个一闪而过的黑框，因此我们需要通过VBscript进行辅助启动。Set ws = CreateObject(&quot;Wscript.Shell&quot;) ws.run &quot;cmd /c lol.bat&quot...",
    "created_at": "2018-06-29T14:19:30.000Z",
    "updated_at": "2018-09-15T08:13:28.000Z",
    "published_at": "2018-09-15T08:13:28.000Z",
    "format": "asl",
    "slug": "lho00s",
    "last_editor": {
      "id": 103147,
      "type": "User",
      "login": "yinzhi",
      "name": "尹挚",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "followers_count": 9,
      "following_count": 5,
      "created_at": "2018-04-23T00:50:24.000Z",
      "updated_at": "2018-11-20T01:24:53.000Z",
      "_serializer": "v2.user"
    },
    "tags": [
      "bat"
    ],
    "date": "2015-01-28 00:00:00 +0800",
    "body": "\n### <a name=\"dovtpi\"></a>通过cmd的启动参数进行窗口隐藏\n\n```\ncmd /c test #后台调用test并关闭当前进程\ncmd /k test #后台调用test但不关闭当前进程\n```\n\n### <a name=\"o9iayb\"></a>通过vbs直接启动\n\ncmd /c 和 cmd /k隐藏控制台窗口时，依然会出现一个一闪而过的黑框，因此我们需要通过VBscript进行辅助启动。\n\n```vbs\nSet ws = CreateObject(\"Wscript.Shell\")\nws.run \"cmd /c lol.bat\",vbhide\n```\n\n"
  },
  {
    "title": "批处理批量重命名",
    "description": "tags: [bat]date: 2015-01-18模拟一下这样的情景，假设我有一个文件夹用于保存各种下载的文本文件（自然也可以是其他格式的文件），当这个文件夹文件数量达到一定规模时，我需要将这些文件的名字序列化，那么下面这个批处理文件便横空出世了。实现代码：@echo off setlocal EnableDelayedExpansion ::下面这个语句要请改成你要处理的文件夹路径如“pushd %~dp0^\\text”改成&quot;pushd &quot;c:\\text&quot;&quot...",
    "created_at": "2018-06-29T14:18:21.000Z",
    "updated_at": "2018-09-15T08:12:36.000Z",
    "published_at": "2018-09-15T08:12:36.000Z",
    "format": "asl",
    "slug": "bwbix7",
    "last_editor": {
      "id": 103147,
      "type": "User",
      "login": "yinzhi",
      "name": "尹挚",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "followers_count": 9,
      "following_count": 5,
      "created_at": "2018-04-23T00:50:24.000Z",
      "updated_at": "2018-11-20T01:24:53.000Z",
      "_serializer": "v2.user"
    },
    "tags": [
      "bat"
    ],
    "date": "2015-01-18 00:00:00 +0800",
    "body": "\n模拟一下这样的情景，假设我有一个文件夹用于保存各种下载的文本文件（自然也可以是其他格式的文件），当这个文件夹文件数量达到一定规模时，我需要将这些文件的名字序列化，那么下面这个批处理文件便横空出世了。\n\n### <a name=\"gauqhp\"></a>实现代码：\n\n```\n@echo off\nsetlocal EnableDelayedExpansion\n::下面这个语句要请改成你要处理的文件夹路径如“pushd %~dp0^\\text”改成\"pushd \"c:\\text\"\"\npushd %~dp0^\\text\n::计数\nset /a index = 0\nfor /f %%i in ('dir /b /a-d *.*') do (\nset /a index += 1\nren %%~nxi !index!%%~xi\n)\necho 共扫描到!index!个文件。\npause>nul\n```\n\n*ps：请将以上代码用任意文本编辑器保存为后缀名为\"bat\"或者\"cmd\"的文件。*\n"
  },
  {
    "title": "批处理文本合并",
    "description": "tags: [bat]date: 2015-01-21使用批处理进行多个文本内容的筛选及合并案例为连接文本1的奇数行，文本2的行数对2整除的行及行数对3整除的行用法：命令格式: [this text1 text2 destText] 例子：this 1.txt 2.txt 3.txt (其中this为下面的代码保存后的文件名)&lt;!-- more --&gt;@echo off title 文本连接 setlocal enabledelayedexpansion cd. &gt; %3 set...",
    "created_at": "2018-06-29T14:16:54.000Z",
    "updated_at": "2018-09-15T08:13:01.000Z",
    "published_at": "2018-09-15T08:13:01.000Z",
    "format": "asl",
    "slug": "xtbi4g",
    "last_editor": {
      "id": 103147,
      "type": "User",
      "login": "yinzhi",
      "name": "尹挚",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/103147/1537198582768-55bfaa8f-150c-47cd-a259-dc06f1082ea5.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "followers_count": 9,
      "following_count": 5,
      "created_at": "2018-04-23T00:50:24.000Z",
      "updated_at": "2018-11-20T01:24:53.000Z",
      "_serializer": "v2.user"
    },
    "tags": [
      "bat"
    ],
    "date": "2015-01-21 00:00:00 +0800",
    "body": "\n### <a name=\"ho4obz\"></a>使用批处理进行多个文本内容的筛选及合并\n\n案例为连接文本1的奇数行，文本2的行数对2整除的行及行数对3整除的行\n\n### <a name=\"5h4zhp\"></a>用法：\n\n命令格式: [this text1 text2 destText]\n例子：`this 1.txt 2.txt 3.txt` (其中this为下面的代码保存后的文件名)\n\n<!-- more -->\n\n```bash\n@echo off\ntitle 文本连接\nsetlocal enabledelayedexpansion\ncd. > %3\nset line1 = 0\nset line2 = 0\nset line3 = 0\nfor /f \"delims=\" %%i in (%1) do (\n\tset /a line1 += 1 && set /a flag = !line1!%%2 && if \"!flag!\"==\"1\" (set /a n+=1&call,set \"_%%n%%=%%i\")\n\t)\nfor /f \"delims=\" %%i in (%1) do (\n\tset /a line2 += 1 && set /a flag1 = !line2!%%2 && if \"!flag1!\"==\"0\" (set /a t+=1&call,set \",%%t%%=%%i\")\n\t)\nfor /f \"delims=\" %%i in (%2) do (\n\tset /a line3 += 1 && set /a flag2 = !line3!%%3 && if \"!flag2!\"==\"0\" (set /a m+=1&call,set \".%%m%%=%%i\")\n\t)\n\nif %n% gtr %m% (set \"num=%n%\") else (set \"num=%m%\")\n(for /l %%i in (1,1,%num%) do (\nif defined _%%i call,echo %%_%%i%%\nif defined _%%i call,echo %%,%%i%%\nif defined .%%i call,echo %%.%%i%%\n)) >> %3\n\nendlocal\nnotepad %3\npause\n```\n\n"
  }
]